# 第一章 检索数据
## 1. SQL语言的规则和规范
### （1）基本规则
1.命令可以随意换行
并不是按了回车键就提交命令了，只要按回车键的时候输入的语句里没有;、\g或者\G这些语句结束符号，该语句就算是没结束。比如上边查询当前时间的命令还可以这么写：
```sql
mysql> SELECT
    -> NOW()
    -> ;
+---------------------+
| NOW()               |
+---------------------+
| 2018-02-06 17:57:15 |
+---------------------+
1 row in set (0.00 sec)

mysql>
```
2.可以一次提交多个命令
我们可以在一条语句里写多个命令(命令之间用上面说的结束符分隔)，比如这样：
```sql
mysql> SELECT NOW(); SELECT NOW(); SELECT NOW();
+---------------------+
| NOW()               |
+---------------------+
| 2018-02-06 18:00:05 |
+---------------------+
1 row in set (0.00 sec)

+---------------------+
| NOW()               |
+---------------------+
| 2018-02-06 18:00:05 |
+---------------------+
1 row in set (0.00 sec)

+---------------------+
| NOW()               |
+---------------------+
| 2018-02-06 18:00:05 |
+---------------------+
1 row in set (0.00 sec)

mysql>
```
3.每条命令以 ; 或 \g 或 \G 结束
比如说我们执行一个简单的查询当前时间的命令：
```sql
mysql> SELECT NOW();
+---------------------+
| NOW()               |
+---------------------+
| 2018-02-06 17:50:55 |
+---------------------+
1 row in set (0.00 sec)

mysql>
```
其中的SELECT意味着这是一个查询命令，NOW()是MySQL内置的函数，用于返回当前时间（我们现在并不是深究具体的某个命令是什么意思，只是想介绍一下书写命令时需要注意的一些事情，所以大家不要纠结函数是个啥，我们后边会讲的）。结果中1 row in set (0.00 sec)的意思是结果只有1行数据，用时0.00秒。使用\g可以起到一样的效果：
```sql
mysql> SELECT NOW()\g
+---------------------+
| NOW()               |
+---------------------+
| 2018-02-06 17:50:55 |
+---------------------+
1 row in set (0.00 sec)

mysql>
```
\G有一点特殊，它并不以表格的形式返回查询结果，而是以垂直的形式将每个列都展示在单独的一行中：
```sql
mysql> SELECT NOW()\G
*************************** 1. row ***************************
NOW(): 2018-02-06 17:51:51
1 row in set (0.00 sec)

mysql>
```
4.关键字不能被缩写也不能分行
5.关于标点符号 

- 必须保证所有的()、单引号、双引号是成对结束的
- 必须使用英文状态下的半角输入方式
- 字符串型和日期时间类型的数据可以使用单引号（' '）表示

在命令里有时会使用到字符串，我们可以使用单引号''或者双引号""把字符串内容引起来，比如这样：
```sql
mysql> SELECT 'aaa';
+-----+
| aaa |
+-----+
| aaa |
+-----+
1 row in set (0.00 sec)

mysql>
```
这个语句只是简单的把字符串'aaa'又输出来了而已。但是一定要在字符串内容上加上引号，不然的话MySQL服务器会把它当作列名，比如这样就会返回一个错误：
```sql
mysql> SELECT aaa;
ERROR 1054 (42S22): Unknown column 'aaa' in 'field list'
mysql>
```
但是MySQL中有一种叫ANSI_QUOTES的模式，如果开启了这种模式，双引号就有其他特殊的用途了，至于是什么用途对于小白的你并不重要，你也不需要理解什么是个ANSI_QUOTES模式，重要的建议你最好使用**单引号来表示字符串**～
当一条命令从客户端发送给了MySQL服务器之后，服务器处理完后就会给客户端发送回来处理结果，然后显示到界面上。然后你就可以接着输入下一条命令了。

- 列的别名，尽量使用双引号（" "），而且不建议省略as
### （2) SQL大小写规范（建议遵守）

- MySQL 在 Windows 环境下是大小写不敏感的
- MySQL 在 Linux 环境下是大小写敏感的 
   - 数据库名、表名、表的别名、变量名是严格区分大小写的
   - 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。
- 推荐采用统一的书写规范： 
   - 数据库名、表名、表别名、字段名、字段别名等都小写
   - SQL 关键字、函数名、绑定变量等都大写

MySQL默认对命令的大小写并没有限制，也就是说我们这样查询当前时间也是可以的：
```sql
mysql> select now();
+---------------------+
| now()               |
+---------------------+
| 2018-02-06 18:23:01 |
+---------------------+
1 row in set (0.00 sec)

mysql>
```
不过按照习俗，这些命令、函数什么的都是要大写的，而一些名称类的东西，比如数据库名，表名、列名啥的都是要小写的，更多具体的书写规范等我们遇着再详细介绍。
### （3) 注释
```sql
单行注释：#注释文字(MySQL特有的方式)
单行注释：-- 注释文字(--后面必须包含一个空格。)
多行注释：/* 注释文字 */
```
### （4) 命名规则
像数据库名、表名、列名、约束名称或者我们之后会遇到的别的名称，这些名称统统被称为标识符。虽然MySQL中对标识符的命名没多少限制，但是却不欢迎下边的这几种命名：

1. 名称中全都是数字。

因为在一些MySQL语句中也会使用到数字，如果你起的名称中全部都是数字，会让MySQL服务器分别不清哪个是名称，哪个是数字了。比如名称1234567就是非法的。

2. 名称中有空白字符

MySQL命令是靠空白字符来分隔各个单词的，比如下边这两行命令是等价的：
```sql
CREATE DATABASE xiaohaizi;
CREATE   DATABASE   xiaohaizi;
```
但是如果你定义的名称中有空白字符，这样会被当作两个词去处理，就会造成歧义。比如名称word1 word2 word3就是非法的。

3. 名称使用了MySQL中的保留字

比方说CREATE、DATABASE、INT、DOUBLE、DROP、TABLE等等这些单词，这些单词都是供MySQL内部使用的，称之为保留字。如果你自己定义的名称用到了这些词儿也会导致歧义。比如名称create就是非法的。
虽然某些名称可能会导致歧义，但是如果你坚持要使用的话，也不是不行，你可以使用反引号``来将你定义的名称扩起来，这样MySQL的服务器就能检测到你提供的是一个名称而不是别的什么东西，比如说把上边几个非法的名称加上反引号``就变成合法的名称了：
```sql
`1234567`
`word1 word2    word3`
`create`
```
我们上边对表first_table的定义可以把里边的标识符全都使用反引号``引起来，这样语义更清晰一点：
```sql
CREATE TABLE `first_table` (
    `id` int UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    `first_column` INT,
    `second_column` VARCHAR(100) DEFAULT 'abc'
);
```
虽然反引号比较强大，但是我们还是建议大家不要起各种非主流的名称，也不要使用全数字、带有空白字符或者MySQL保留字的名称。由于MySQL是C语言实现的，所以在名称定义上还是尽量遵从C语言的规范吧，就是用小写字母、数字、下划线、美元符号等作为名称，如果有多个单词的话，各个单词之间用下划线连接起来，比如student、student_info啥的～
4.数据库、表名不得超过30个字符，变量名限制为29个
5.必须只能包含 A–Z, a–z, 0–9, _共63个字符
6.同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；
7.保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了
### （5）数据的导入
方法一：source 文件的全路径名
在命令行客户端登录mysql，使用source指令导入
导入的是数据库
```sql
source C:\Users\lenovo\OneDrive\桌面\数据分析\资料\atguigudb.sql;
```
方法二：基于基本的图形化界面的工具可以导入数据

## 2. 基本的SELECT语句
SELECT 语句：它的用途是从一个或多个表中检索信息
### （1）SELECT...
```sql
SELECT 1; #没有任何子句
SELECT 9/2; #没有任何子句
```
### （2） SELECT ... FROM

- **语法**
```sql
SELECT 检索哪些列
FROM 从哪个表中选择
```
例：
```sql
SELECT prod_name
FROM Products;
```
上述语句利用 SELECT 语句从 Products 表中检索一个名为 prod_name的列。所需的列名写在 SELECT 关键字之后， FROM 关键字指出从哪个表中检索数据。此语句的输出如下所示：
```sql
prod_name
-------------------
Fish bean bag toy
Bird bean bag toy
Rabbit bean bag toy
8 inch teddy bear
12 inch teddy bear
18 inch teddy bear
Raggedy Ann
King doll
Queen doll
```

- **选择全部列**
```sql
SELECT *
FROM departments;
```
表示检索departments表的所有列

- **选择多个列**

要想从一个表中检索多个列，仍然使用相同的 SELECT 语句。唯一的不同是必须在 SELECT 关键字后给出多个列名，列名之间必须以逗号分隔。
注意：当心逗号：在选择多个列时，一定要在列名之间加上逗号，但最后一个列名后不加。如果在最后一个列名后加了逗号，将出现错误。
下面的 SELECT 语句从 Products 表中选择 3列。
```sql
SELECT prod_id, prod_name, prod_price
FROM Products;
```
输出：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717075026090-da1e2db6-d842-42e7-a963-ab86fc52838d.png#averageHue=%23f2f2f2&clientId=ub6b0e447-eb2a-4&from=paste&height=299&id=u99cd7d13&originHeight=374&originWidth=916&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=65222&status=done&style=none&taskId=u5ed905ba-f936-4a3a-b662-c097a12fe3c&title=&width=732.8)
### （3）列的别名

- 重命名一个列
- 便于计算
- 别名在列名的后面，中间隔着空格，**也可以在列名和别名之间加入关键字AS，或者别名使用双引号**，以便在别名中包含空格或特殊的字符并区分大小写。
- AS 可以省略
- 建议别名简短，见名知意
- 例1：
```sql
SELECT last_name AS name, commission_pct comm
# commission_pct的别名是comm,把AS省略了
FROM employees;
```
输出：
```sql
+-------------+------+
| name        | comm |
+-------------+------+
| King        | NULL |
| Kochhar     | NULL |
| De Haan     | NULL |
| Hunold      | NULL |
| Ernst       | NULL |
| Austin      | NULL |
| Pataballa   | NULL |
| Lorentz     | NULL |
| Greenberg   | NULL |
| Faviet      | NULL |
……  # 只复制了一部分结果
```

- 例2：
```sql
SELECT last_name "Name", salary*12 "Annual Salary"
FROM employees;
```
输出：
```sql
+-------------+---------------+
| Name        | Annual Salary |
+-------------+---------------+
| King        |     288000.00 |
| Kochhar     |     204000.00 |
| De Haan     |     204000.00 |
| Hunold      |     108000.00 |
| Ernst       |      72000.00 |
| Austin      |      57600.00 |
| Pataballa   |      57600.00 |
| Lorentz     |      50400.00 |
| Greenberg   |     144000.00 |
| Faviet      |     108000.00 |
| Chen        |      98400.00 |
| Sciarra     |      92400.00 |
……
```
MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。
### （4） 去除重复行
默认情况下，查询会返回全部行，包括重复行。
```sql
SELECT department_id
FROM  employees;
```
在SELECT语句中使用**关键字DISTINCT**去除重复行
```sql
SELECT DISTINCT department_id
FROM  employees;
```
输出：
```sql
+---------------+
| department_id |
+---------------+
|          NULL |
|            10 |
|            20 |
|            30 |
|            40 |
|            50 |
|            60 |
|            70 |
|            80 |
|            90 |
|           100 |
|           110 |
+---------------+
12 rows in set (0.01 sec)
```
针对于：
```sql
SELECT DISTINCT department_id,salary
FROM employees;
```
输出：
```sql
+---------------+----------+
| department_id | salary   |
+---------------+----------+
|            90 | 24000.00 |
|            90 | 17000.00 |
|            60 |  9000.00 |
|            60 |  6000.00 |
|            60 |  4800.00 |
|            60 |  4200.00 |
|           100 | 12000.00 |
|           100 |  9000.00 |
|           100 |  8200.00 |
|           100 |  7700.00 |
|           100 |  7800.00 |
|           100 |  6900.00 |
|            30 | 11000.00 |
……
```
需要注意的是：
DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门(department_id)只需要写 **DISTINCT department_id**即可，后面不需要再加其他的列名了。
### （5）空值参与运算
空值：null ( 不等同于0, ’ ‘, ’null‘ )
所有运算符或列值遇到null值，运算的结果都为null
实际问题的解决方案：引入IFNULL
```sql
SELECT employee_id, salary "月工资",
salary * (1 + IFNULL(commission_pct, 0)) * 12 "年工资" 
FROM employees;
```
这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长 度是空。而且，在 MySQL 里面，空值是占用空间的。
### （6）着重号 ``

- 错误的：
```sql
mysql> SELECT * FROM ORDER;
# ORDER是关键字
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'ORDER' at line 1
```

- 正确的：
```sql
mysql> SELECT * FROM `ORDER`;
+----------+------------+
| order_id | order_name |
+----------+------------+
|        1 | shkstart   |
|        2 | tomcat     |
|        3 | dubbo      |
+----------+------------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM `order`;
+----------+------------+
| order_id | order_name |
+----------+------------+
|        1 | shkstart   |
|        2 | tomcat     |
|        3 | dubbo      |
+----------+------------+
3 rows in set (0.00 sec)
```

- 结论

我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对``（着重号）引起来。
### （7）查询常数
SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。
你可能会问为什么我们还要对常数进行查询呢？
SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。
比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段 corporation ，这个字段固定值为“尚硅谷”，可以这样写：
```sql
mysql> SELECT '尚硅谷' as corporation, last_name FROM employees;
+-------------+-------------+
| corporation | last_name   |
+-------------+-------------+
| 尚硅谷      | King        |
| 尚硅谷      | Kochhar     |
| 尚硅谷      | De Haan     |
| 尚硅谷      | Hunold      |
| 尚硅谷      | Ernst       |
| 尚硅谷      | Austin      |
| 尚硅谷      | Pataballa   |
| 尚硅谷      | Lorentz     |
| 尚硅谷      | Greenberg   |
| 尚硅谷      | Faviet      |
| 尚硅谷      | Chen        |
| 尚硅谷      | Sciarra     |
……
```
## 3. 显示表结构
使用DESCRIBE 或 DESC 命令，表示表结构。
```sql
DESCRIBE employees;
或
DESC employees;
```

```sql
mysql> desc employees;
+----------------+-------------+------+-----+---------+-------+
| Field          | Type        | Null | Key | Default | Extra |
+----------------+-------------+------+-----+---------+-------+
| employee_id    | int         | NO   | PRI | 0       |       |
| first_name     | varchar(20) | YES  |     | NULL    |       |
| last_name      | varchar(25) | NO   |     | NULL    |       |
| email          | varchar(25) | NO   | UNI | NULL    |       |
| phone_number   | varchar(20) | YES  |     | NULL    |       |
| hire_date      | date        | NO   |     | NULL    |       |
| job_id         | varchar(10) | NO   | MUL | NULL    |       |
| salary         | double(8,2) | YES  |     | NULL    |       |
| commission_pct | double(2,2) | YES  |     | NULL    |       |
| manager_id     | int         | YES  | MUL | NULL    |       |
| department_id  | int         | YES  | MUL | NULL    |       |
+----------------+-------------+------+-----+---------+-------+
11 rows in set (0.02 sec)
```
其中，各个字段的含义分别解释如下：

- Field：表示字段名称。
- Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。
- Null：表示该列是否可以存储NULL值。
- Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一

部分；MUL表示在列中某个给定值允许出现多次。

- Default：表示该列是否有默认值，如果有，那么值是多少。
- Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。
## 4. 过滤数据

- 语法：
```sql
SELECT 字段1,字段2
FROM 表名
WHERE 过滤条件
```

   - 使用WHERE 子句，将不满足条件的行过滤掉。
   - **WHERE子句紧随 FROM子句。**
- 举例：返回在90号部门工作的所有员工的信息
```sql
mysql> SELECT employee_id, last_name, job_id, department_id
    -> FROM employees
    -> WHERE department_id = 90;
+-------------+-----------+---------+---------------+
| employee_id | last_name | job_id  | department_id |
+-------------+-----------+---------+---------------+
|         100 | King      | AD_PRES |            90 |
|         101 | Kochhar   | AD_VP   |            90 |
|         102 | De Haan   | AD_VP   |            90 |
+-------------+-----------+---------+---------------+
3 rows in set (0.01 sec)
```
# 第二章 运算符
## 表达式、操作数、操作符
### 表达式
学过小学数学的我们应该知道，将数字和运算符连接起来的组合称之为表达式，比方说这样：
```
复制代码1 + 1
5 * 8
```
我们可以将其中的数字称之为操作数，运算符可以称之为操作符。特殊的，单个操作数也可以被看作是一个特殊的表达式。
在MySQL中也有表达式的概念，不过操作数和操作符的含义有了扩充。下边详细看一下。
### 操作数
MySQL中操作数可以是下边这几种类型：

1. 常数

常数很好理解，我们平时用到的数字、字符串、时间值什么的都可以被称为常数，它是一个确定的值，比如数字1，字符串'abc'，时间值2019-08-16 17:10:43啥的。

2. 列名

针对某个具体的表，它的列名可以被当作表达式的一部分，比如对于student_info表来说，number、name都可以作为操作数。

3. 函数调用

MySQL中有函数的概念，比方说获取当前时间的函数NOW，而在函数后边加个小括号就算是一个函数调用，比如NOW()。
```
复制代码如果你不清楚函数的概念，我们之后会详细唠叨的，现在不知道也可以～
```

4. 标量子查询或者行子查询

这个子查询我们稍后会详细唠叨的～

5. 其他表达式

一个表达式也可以作为一个操作数与另一个操作数来形成一个更复杂的表达式，比方说（假设col是一个列名）：

   - (col - 5) / 3
   - (1 + 1) * 2 + col * 3
```
!

复制代码小贴士：

当然，可以作为操作数的东西不止这么几种，不过我们这是一个入门书籍，大家在熟练使用MySQL后再到文档中查看更多的操作数类型吧。
```
### 操作符
对于小白的我们来说，目前熟悉掌握下边三种操作符就应该够用了：

1. 算术操作符

就是加减乘除法那一堆，

2. 比较操作符

就是在搜索条件中我们已经看过的比较操作符，
由比较操作符连接而成的表达式也称为布尔表达式，表示真或者假，也可以称为TRUE或者FALSE。比如1 > 3就代表FALSE，3 != 2就代表TRUE。

3. 逻辑操作符

逻辑操作符是用来将多个布尔表达式连接起来
## 1. 算术运算符
算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。

| 运算符 | 名称 | 作用 | 示例 |
| --- | --- | --- | --- |
| + | 加法运算符 | 计算两个值或表达式的和 | SELECT A + B |
| - | 减法运算符 | 计算两个值或表达式的差 | SELECT A - B |
| * | 乘法运算符 | 计算两个值或表达式的乘积 | SELECT A * B |
| /或DIV | 除法运算符 | 计算两个值或表达式的商 | SELECT A / B 或者 SELECT A DIV B |
| %或MOD | 求模(求余)运算符 | 计算两个值或表达式的余数 | SELECT A % B 或者 SELECT A MOD B |

### 1.加法与减法运算符
对dual表中的100进行加减运算
```sql
mysql> SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5;
+-----+---------+---------+----------+--------------+------------+------------+
| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |
+-----+---------+---------+----------+--------------+------------+------------+
| 100 |     100 |     100 |      150 |          120 |      135.5 |       64.5 |
+-----+---------+---------+----------+--------------+------------+------------+
1 row in set (0.01 sec)
```
> - 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；
> - 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；
> - 在Java中， + 的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中 + 只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（注：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）
> - 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。

### 2.乘法与除法运算符
```sql
mysql> SELECT 100, 100 * 1, 100 / 1.0, 100 / 2, 100 + 2 * 5 / 2, 100 / 3, 100 DIV 0
    -> FROM dual;
+-----+---------+-----------+---------+-----------------+---------+-----------+
| 100 | 100 * 1 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 / 3 | 100 DIV 0 |
+-----+---------+-----------+---------+-----------------+---------+-----------+
| 100 |     100 |  100.0000 | 50.0000 |        105.0000 | 33.3333 |      NULL |
+-----+---------+-----------+---------+-----------------+---------+-----------+
1 row in set (0.00 sec)
```
由运算结果可以得出如下结论：
> - 一个数乘以整数1和除以整数1后仍得原数；
> - 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；
> - 一个数除以整数后，不管是否能除尽，结果都为一个浮点数；
> - 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；
> - 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。
> - 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。

### 3.求模（求余）运算符 
```sql
mysql> SELECT 12 % 3, 12 MOD 5 FROM dual;
+--------+----------+
| 12 % 3 | 12 MOD 5 |
+--------+----------+
|      0 |        2 |
+--------+----------+
1 row in set (0.00 sec)
```
## 2. 比较运算符
比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。
比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。

| 操作符 | 示例 | 描述 |
| --- | --- | --- |
| = | a = b | a等于b |
| <=> 安全等于运算符 | a <=> b | 安全地判断两个值、字符串或表达式是否相等 |
| <>或者!= | a <> b | a不等于b |
| < | a < b | a小于b |
| <= | a <= b | a小于或等于b |
| > | a > b | a大于b |
| >= | a >= b | a大于或等于b |
| BETWEEN | a BETWEEN b AND c | 满足 b <= a <= c |
| NOT BETWEEN | a NOT BETWEEN b AND c | 不满足 b <= a <= c |
| IN | a IN (b1, b2, ...) | a是b1, b2, ... 中的某一个 |
| NOT IN | a NOT IN (b1, b2, ...) | a不是b1, b2, ... 中的任意一个 |
| IS NULL | a IS NULL | a的值是NULL |
| IS NOT NULL | a IS NOT NULL | a的值不是NULL |
| LIKE | a LIKE b | a匹配b |
| NOT LIKE | a NOT LIKE b | a不匹配b |

### （1）等号运算符

- 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。
- 在使用等号运算符时，遵循如下规则：
   - 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。
   - 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。
   - 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。
   - 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。
- 对比：SQL中赋值符号使用 :=
```sql
mysql> SELECT 1 = 1, 1 = '1', 1 = 0, 'a' = 'a', (5 + 3) = (2 + 6), '' = NULL , NULL = NULL;
+-------+---------+-------+-----------+-------------------+-----------+-------------+
| 1 = 1 | 1 = '1' | 1 = 0 | 'a' = 'a' | (5 + 3) = (2 + 6) | '' = NULL | NULL = NULL |
+-------+---------+-------+-----------+-------------------+-----------+-------------+
|     1 |       1 |     0 |         1 |                 1 |      NULL |        NULL |
+-------+---------+-------+-----------+-------------------+-----------+-------------+
1 row in set (0.01 sec)
```
```sql
mysql> SELECT 1 = 2, 0 = 'abc', 1 = 'abc' FROM dual;
+-------+-----------+-----------+
| 1 = 2 | 0 = 'abc' | 1 = 'abc' |
+-------+-----------+-----------+
|     0 |         1 |         0 |
+-------+-----------+-----------+
1 row in set, 2 warnings (0.01 sec)
```
```sql
mysql> SELECT 1 <=> '1', 1 <=> 0, 'a' <=> 'a', (5 + 3) <=> (2 + 6), '' <=> NULL,NULL <=> NULL FROM dual;
+-----------+---------+-------------+---------------------+-------------+---------------+
| 1 <=> '1' | 1 <=> 0 | 'a' <=> 'a' | (5 + 3) <=> (2 + 6) | '' <=> NULL | NULL <=> NULL |
+-----------+---------+-------------+---------------------+-------------+---------------+
|         1 |       0 |           1 |                   1 |           0 |             1 |
+-----------+---------+-------------+---------------------+-------------+---------------+
1 row in set (0.00 sec)
```
可以看到，使用**安全等于运算符**时，**两边的操作数的值都为NULL**时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同。
### （2）不等于运算符
不等于运算符（<>和!=）用于判断两边的数字、字符串或者表达式的值是否不相等， 如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL， 或两边都为NULL，则结果为NULL。 SQL语句示例如下：
```sql
mysql> SELECT 1 <> 1, 1 != 2, 'a' != 'b', (3+4) <> (2+6), 'a' != NULL, NULL <> NULL;
+--------+--------+------------+----------------+-------------+--------------+
| 1 <> 1 | 1 != 2 | 'a' != 'b' | (3+4) <> (2+6) | 'a' != NULL | NULL <> NULL |
+--------+--------+------------+----------------+-------------+--------------+
|      0 |      1 |          1 |              1 |        NULL |         NULL |
+--------+--------+------------+----------------+-------------+--------------+
1 row in set (0.00 sec)
```
此外，还有非符号类型的运算符：

| **运算符** | **作用** | **示例** |
| --- | --- | --- |
| IN | 判断一个值是否为列表中的任意一个值 | select d from table where c in(a,b) |
| NOT IN | 判断一个值是否不是列表中的任意一个值 | select d from table where c not in(a,b) |
| ISNULL | 判断值、字符串或表达式是否为空 | select a from table where a isnull |
| IS NOT NULL | 判断值、字符串或表达式是否不为空 | select a from table where a is not null |
| LEAST | 在多个值中返回最小值 | select d from table where c least(a,b) |
| GREATEST | 在多个值中返回最大值 | select d from table where c greatest(a,b) |
| BETWEEN AND | 判断一个值是否在两个值之间 | select d from table where c between a and b;
等价于 select d from table where c >= and c<= b |
| LIKE | 判断一个值是否符合模糊匹配的规则 | select a from table where b like ‘%_%’ |
| REGEXP | 判断一个值是否符合正则表达式的规则 | select a from table where b regexp ’ ’ |

### （3）空运算符
空运算符 (IS NULL 或者 ISNULL) 判断一个值是否为NULL，如果为NULL则返回1，否则返回0。
```sql
mysql> SELECT NULL IS NULL, ISNULL(NULL), ISNULL('a'), 1 IS NULL;
+--------------+--------------+-------------+-----------+
| NULL IS NULL | ISNULL(NULL) | ISNULL('a') | 1 IS NULL |
+--------------+--------------+-------------+-----------+
|            1 |            1 |           0 |         0 |
+--------------+--------------+-------------+-----------+
1 row in set (0.01 sec)
```
```sql
#查询commission_pct等于NULL。比较如下的四种写法
SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;
SELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> NULL;
SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);
SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;
```
### （4） 非空运算符
非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。
```sql
mysql> SELECT NULL IS NOT NULL, 'a' IS NOT NULL, 1 IS NOT NULL;
+------------------+-----------------+---------------+
| NULL IS NOT NULL | 'a' IS NOT NULL | 1 IS NOT NULL |
+------------------+-----------------+---------------+
|                0 |               1 |             1 |
+------------------+-----------------+---------------+
1 row in set (0.00 sec)
```
### （5）最小值运算符
语法格式为：LEAST(值1，值2，...，值n)。其中，“值n”表示参数列表中有n个值。在有 两个或多个参数的情况下，返回最小值。
```sql
mysql> SELECT LEAST (1,0,2), LEAST('b','a','c'), LEAST(1,NULL,2);
+---------------+--------------------+-----------------+
| LEAST (1,0,2) | LEAST('b','a','c') | LEAST(1,NULL,2) |
+---------------+--------------------+-----------------+
|             0 | a                  |            NULL |
+---------------+--------------------+-----------------+
1 row in set (0.01 sec)
```
由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字 母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。
### （6）最大值运算符
语法格式为：GREATEST(值1，值2，...，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。
```sql
mysql> SELECT GREATEST(1,0,2), GREATEST('b','a','c'), GREATEST(1,NULL,2);
+-----------------+-----------------------+--------------------+
| GREATEST(1,0,2) | GREATEST('b','a','c') | GREATEST(1,NULL,2) |
+-----------------+-----------------------+--------------------+
|               2 | c                     |               NULL |
+-----------------+-----------------------+--------------------+
1 row in set (0.00 sec)
```
由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时， 返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。
### （7) BETWEEN AND运算符
BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。

| BETWEEN | a BETWEEN b AND c | 满足 b <= a <= c |
| --- | --- | --- |

```sql
mysql> SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, 'b' BETWEEN 'a' AND 'c';
+-------------------+----------------------+-------------------------+
| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | 'b' BETWEEN 'a' AND 'c' |
+-------------------+----------------------+-------------------------+
|                 1 |                    0 |                       1 |
+-------------------+----------------------+-------------------------+
1 row in set (0.01 sec)
```
### （8）IN运算符
IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。
```sql
mysql> SELECT 'a' IN ('a','b','c'), 1 IN (2,3), NULL IN ('a','b'), 'a' IN ('a', NULL);
+----------------------+------------+-------------------+--------------------+
| 'a' IN ('a','b','c') | 1 IN (2,3) | NULL IN ('a','b') | 'a' IN ('a', NULL) |
+----------------------+------------+-------------------+--------------------+
|                    1 |          0 |              NULL |                  1 |
+----------------------+------------+-------------------+--------------------+
1 row in set (0.00 sec)
```
### （9）NOT IN运算符
NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。
```sql
mysql> SELECT 'a' NOT IN ('a','b','c'), 1 NOT IN (2,3);
+--------------------------+----------------+
| 'a' NOT IN ('a','b','c') | 1 NOT IN (2,3) |
+--------------------------+----------------+
|                        0 |              1 |
+--------------------------+----------------+
1 row in set (0.00 sec)
```
### （10）LIKE运算符：模糊查询
LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回 0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。

| LIKE | a LIKE b | a匹配b |
| --- | --- | --- |

LIKE运算符通常使用如下通配符：
```sql
“%”：匹配0个或多个字符。
“_”：只能匹配一个字符。
```
①%
```sql
mysql> SELECT first_name
    -> FROM employees
    -> WHERE first_name LIKE '%he%';
# 检索出所有包含he的名字，并不是必须开头有
+-------------+
| first_name  |
+-------------+
| Shelli      |
| Matthew     |
| Mozhe       |
| Stephen     |
| Christopher |
| Hermann     |
| Shelley     |
+-------------+
7 rows in set (0.00 sec)
```
```sql
mysql> SELECT first_name
    -> FROM employees
    -> WHERE first_name LIKE 'she%';
    # 检索出所有开头是she的名字
+------------+
| first_name |
+------------+
| Shelli     |
| Shelley    |
+------------+
2 rows in set (0.00 sec)
```
```sql
# 查询last_name中包含字符a且包含字符e的员工信息
# 写法一
mysql> SELECT last_name
    -> FROM employees
    -> WHERE last_name LIKE '%a%' AND last_name LIKE '%e%';
# 写法二
mysql> SELECT last_name
    -> FROM employees
    -> WHERE last_name LIKE '%a%e%' AND last_name LIKE '%e%a%';
```
②_
在SQL中，`_`（下划线）是一种通配符（Wildcard），用于模式匹配操作。具体来说，`_` 通配符用于表示单个字符，可以匹配任意一个字符。在 SQL 查询中，通常与 `LIKE` 操作符一起使用，用于进行字符串的模式匹配。
以下是一些使用 `LIKE` 操作符和 `_` 通配符的示例：

1.  **匹配任意单个字符**： 
```sql
SELECT * FROM Customers
WHERE Name LIKE 'J_n';  -- 匹配 "Jan", "Jen", "Jon" 等等
```

2.  **匹配特定位置的字符**： 
```sql
SELECT * FROM Employees
WHERE EmployeeID LIKE '123_';  -- 匹配 "1231", "123A", "123X" 等等
```

3.  **结合 **`**%**`** 通配符使用**：
`%`（百分号）是另一种通配符，表示零个或多个字符。可以和 `_` 一起使用以进行更复杂的模式匹配。 
```sql
SELECT * FROM Products
WHERE ProductCode LIKE 'A_C%';  -- 匹配 "A1C", "A2C", "A3Code", "A4Car" 等等
```

4.  **实际示例**： 
```sql
-- 假设我们有一个包含用户信息的表 Users，其中包含字段 Username
-- 我们想找到用户名的第二个字符是 'a' 的所有用户
SELECT * FROM Users
WHERE Username LIKE '_a%';  -- 匹配 "Janet", "Marco", "Karen" 等等
```

5.  **转义字符**：
如果需要在字符串中匹配实际的 `_` 字符，需要使用转义字符。不同的数据库系统有不同的转义字符方式。例如在 MySQL 中，可以使用 `ESCAPE` 子句： 
```sql
SELECT * FROM Items
WHERE ItemCode LIKE 'A\_B' ESCAPE '\';  -- 匹配 "A_B" 这个字符串
```
总结来说，`_` 在 SQL 中是一个通配符，用于表示任意一个字符，常与 `LIKE` 操作符一起使用，用于进行字符串的模式匹配。
### （11）ESCAPE
**①反斜杠\**
反斜杠可以用来转义特殊字符，使它们被解释为字面意义而不是特殊含义。
在MySQL中，反斜杠（\）可以用来转义正则表达式中的特殊字符或字符串中的单引号等。
示例：
```sql
SELECT 'It\'s a test.';
```
这行SQL会返回字符串 It's a test.，其中的单引号被反斜杠转义了。
**②ESCAPE**
在SQL中，`ESCAPE`子句用于定义一个转义字符，以处理字符串中包含通配符（如 `%` 和 `_`）的情况。通配符`%`表示零个或多个字符，`_`表示一个字符。如果你想要搜索包含这些特殊字符的字符串，而不是将它们视为通配符，你需要使用转义字符。
以下是 `ESCAPE` 子句的典型用法示例：
**基本用法**
假设你有一个包含商品代码的表 `Products`，其中某些商品代码包含下划线（_），你想要查询这些具体包含下划线的商品代码，而不是将下划线作为通配符使用。
```sql
SELECT * FROM Products
WHERE ProductCode LIKE 'A\_B' ESCAPE '\';
```
在这个示例中，反斜杠（`\`）被指定为转义字符，所以 `A\_B` 将匹配 `A_B` 而不是 `A` 后面跟任意一个字符再跟 `B`。
**详细示例**
假设我们有一个用户信息表 `Users`，其中包含字段 `Username`。

1. **查询包含百分号（%）的用户名**：
```sql
SELECT * FROM Users
WHERE Username LIKE '%\%%' ESCAPE '\';
```
这里，反斜杠（`\`）作为转义字符，所以 `%\%%` 将匹配包含百分号（%）的任意位置的用户名。

2. **查询包含下划线（_）的用户名**：
```sql
SELECT * FROM Users
WHERE Username LIKE '%\_%' ESCAPE '\';
```
在这个查询中，`\_` 被解释为实际的下划线字符，因此`%\_%` 将匹配包含下划线的用户名。

3. **使用不同的转义字符**：

你也可以使用其他字符作为转义字符。例如，用 `#` 作为转义字符：
```sql
SELECT * FROM Users
WHERE Username LIKE '%#_%' ESCAPE '#';
```
在这个例子中，`#_` 将匹配实际的下划线字符。
**注意事项**

- **选择转义字符**：选择一个转义字符时，确保它在数据中不常见，以避免混淆。
- **不同数据库的实现**：不同的数据库管理系统（如 MySQL、PostgreSQL、SQL Server等）对 `ESCAPE` 子句的支持和语法可能略有不同，请参考具体数据库的文档以确认正确的用法。

总结来说，`ESCAPE` 子句在 SQL 查询中非常有用，它允许你定义一个转义字符，以便正确匹配包含特殊通配符的字符串。
### （12）REGEXP运算符
REGEXP运算符用来匹配字符串，语法格式为： 表达式 REGEXP 匹配条件 。如果表达式满足匹配条件，返回1，反之返回0
（1）‘^’匹配以该字符后面的字符开头的字符串。
```sql
# 这个查询将返回所有last_name以字母 ‘A’ 开头的员工。
mysql> SELECT last_name
    -> FROM employees
    -> WHERE last_name REGEXP '^A';
+-----------+
| last_name |
+-----------+
| Austin    |
| Atkinson  |
| Ande      |
| Abel      |
+-----------+
4 rows in set (0.01 sec)
```
（2）‘$’匹配以该字符前面的字符结尾的字符串。
```sql
# 这个查询将返回所有last_name以字母 ‘z’ 结尾的员工 
mysql> SELECT last_name
    -> FROM employees
    -> WHERE last_name REGEXP 'z$';
+-----------+
| last_name |
+-----------+
| Lorentz   |
| Errazuriz |
| Gietz     |
+-----------+
3 rows in set (0.00 sec)
```
（3）‘.’匹配任何一个单字符。
**基本用法**
①匹配任意单个字符
```sql
SELECT * FROM Users WHERE Username REGEXP '^a.b$';
```
这个查询将返回所有 Username 以 ‘a’ 开头、以 ‘b’ 结尾，中间任意一个字符的用户。例如，‘a1b’、‘a_b’、‘a-b’ 都会被匹配。
②匹配任意字符位置
```sql
SELECT * FROM Files WHERE FileName REGEXP 'file.';
```
这个查询将匹配所有文件名以 ‘file’ 开头，后面跟任意一个字符的文件。例如，‘file1’、‘fileX’、‘file.’ 都会被匹配。
（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一 个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。
```sql
SELECT * FROM Users WHERE Username REGEXP '[0-9]';
```
这个查询将返回所有 Username 包含至少一个数字的用户。
（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。
## 3. 逻辑运算符
逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。
MySQL中支持4种逻辑运算符如下：

| 运算符 | 作用 | 示例 |
| --- | --- | --- |
| NOT或! | 逻辑非 | SELECT NOT A |
| AND或&& | 逻辑与 | SELECT A AND B
SELECT A && B |
| OR或&#124;&#124; | 逻辑或 | SELECT A OR B
SELECT A &#124;&#124; B |
| XOR | 逻辑异或 | SELECT A XOR B |

### ![](MySQL%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20220531195405333.png#id=BSZW9&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)（1）逻辑非运算符
逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。
```sql
mysql> SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;
+-------+-------+----------+--------+----------+
| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |
+-------+-------+----------+--------+----------+
|     0 |     1 |        0 |      1 |     NULL |
+-------+-------+----------+--------+----------+
1 row in set, 1 warning (0.01 sec)
```
### （2）逻辑与运算符
逻辑与（AND或&&）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。
```sql
mysql> SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;
+----------+---------+------------+------------+
| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |
+----------+---------+------------+------------+
|        1 |       0 |          0 |       NULL |
+----------+---------+------------+------------+
1 row in set (0.01 sec)
```
### （3）逻辑或运算符
逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。
```sql
mysql> SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;  
+---------+--------+-----------+-----------+--------------+
| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |
+---------+--------+-----------+-----------+--------------+
|       1 |      1 |         1 |      NULL |         NULL |
+---------+--------+-----------+-----------+--------------+
1 row in set, 2 warnings (0.00 sec)
```
**注意**：OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。
### （4）逻辑异或运算符
逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。
```sql
mysql> SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;
+----------+---------+---------+------------+---------------+---------------+
| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |
+----------+---------+---------+------------+---------------+---------------+
|        0 |       1 |       0 |       NULL |             1 |             0 |
+----------+---------+---------+------------+---------------+---------------+
1 row in set (0.00 sec)
```
## 4. 位运算
位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算， 最后将计算结果从二进制变回十进制数。
MySQL支持的位运算符如下：

| 运算符 | 作用 | 示例 |
| --- | --- | --- |
| & | 按位与（位AND） | SELECT A & B |
| &#124; | 按位或（位OR） | SELECT A &#124; B |
| ^ | 按位异或（位XOR） | SELECT A ^ B |
| ~ | 按位取反 | SELECT ~ A |
| >> | 按位右移 | SELECT A >>2 |
| << | 按位左移 | SELECT B << 2 |

### （1）按位与运算符
按位与（&）运算符将&左右两边数对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。
```sql
mysql> SELECT 1 & 10, 20 & 30;
+--------+---------+
| 1 & 10 | 20 & 30 |
+--------+---------+
|      0 |      20 |
+--------+---------+
1 row in set (0.01 sec)
```
![43789c5c6b62ccb8d2bb8b49e1257d1f.jpg](https://cdn.nlark.com/yuque/0/2024/jpeg/33643071/1717328550579-049812c8-24fb-429d-a5ed-8514937e2bc7.jpeg#averageHue=%23f1f1f1&clientId=ucaacc4b2-2fdb-4&from=paste&height=127&id=uc1984848&originHeight=359&originWidth=958&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36935&status=done&style=none&taskId=u97f5d9ce-8bc4-492d-84c6-db44022f7e0&title=&width=340)
0000对应的十进制是0,10100对应的十进制是20
### （2）按位或运算符
按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。
```sql
mysql> SELECT 1 | 10, 20 | 30;
+--------+---------+
| 1 | 10 | 20 | 30 |
+--------+---------+
|     11 |      30 |
+--------+---------+
1 row in set (0.00 sec)
```
1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。
### （3）按位异或运算符
在SQL中，按位异或运算符（^）用于对两个整数的二进制表示进行逐位 “异或” 操作。每个位的结果是这两个位的异或（XOR）：只有当两个位不同（即一个是1，另一个是0）时，结果位才为1，否则为0。
```sql
mysql> SELECT 1 ^ 10, 20 ^ 30;
+--------+---------+
| 1 ^ 10 | 20 ^ 30 |
+--------+---------+
|     11 |      10 |
+--------+---------+
1 row in set (0.00 sec)
```
1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。
### （4）按位取反运算符
按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。
```sql
mysql> SELECT 10 & ~1;
+---------+
| 10 & ~1 |
+---------+
|      10 |
+---------+
1 row in set (0.00 sec)
```
### （5）按位右移运算符 
按位右移（>>）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。
```sql
mysql> SELECT 1 >> 2, 4 >> 2;
+--------+--------+
| 1 >> 2 | 4 >> 2 |
+--------+--------+
|      0 |      1 |
+--------+--------+
1 row in set (0.00 sec)
```
### （6）按位左移运算符 
按位左移（<<）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。
```sql
mysql> SELECT 1 << 2, 4 << 2;
+--------+--------+
| 1 << 2 | 4 << 2 |
+--------+--------+
|      4 |     16 |
+--------+--------+
1 row in set (0.00 sec)
```
## 5. 运算符的优先级
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717331533516-f793d520-93f3-43f0-b193-e9a470242933.png#averageHue=%23f2f2f2&clientId=ucaacc4b2-2fdb-4&from=paste&height=462&id=u06f5cca7&originHeight=577&originWidth=929&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77484&status=done&style=none&taskId=ue399edbf-fb12-40ff-b93f-dfa82575771&title=&width=743.2)
数字编号越大，优先级越高，优先级高的运算符先进行计算。
## 扩展：使用正则表达式查询
正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。
MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。
![](MySQL%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20220531204253508.png#id=ew8YI&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717331672673-c718f33a-8ba2-403d-bc3c-2ba6238485f7.png#averageHue=%23ececec&clientId=ucaacc4b2-2fdb-4&from=paste&height=526&id=ucedc5b57&originHeight=657&originWidth=934&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=299262&status=done&style=none&taskId=u5070a746-8c0a-451d-ba54-097addf1584&title=&width=747.2)
# 第三章 排序与分页
## 1. 排序规则
ORDER BY 子句在SQL中用于对查询结果进行排序。它可以按一个或多个列的值进行升序（ASC）或降（DESC）排序。默认情况下，ORDER BY 子句会以升序排序。

-  使用 ORDER BY 子句排序 
   - **ASC（ascend）: 升序**
   - **DESC（descend）:降序**
- ** ORDER BY 子句在SELECT语句的结尾。 **
### （1） 单列排序
```sql
mysql> SELECT last_name, job_id, department_id, hire_date
    -> FROM employees
    -> ORDER BY hire_date;
+-------------+------------+---------------+------------+
| last_name   | job_id     | department_id | hire_date  |
+-------------+------------+---------------+------------+
| King        | AD_PRES    |            90 | 1987-06-17 |
| Whalen      | AD_ASST    |            10 | 1987-09-17 |
| Kochhar     | AD_VP      |            90 | 1989-09-21 |
| Hunold      | IT_PROG    |            60 | 1990-01-03 |
| Ernst       | IT_PROG    |            60 | 1991-05-21 |
| De Haan     | AD_VP      |            90 | 1993-01-13 |
| Mavris      | HR_REP     |            40 | 1994-06-07 |
| Baer        | PR_REP     |            70 | 1994-06-07 |
| Higgins     | AC_MGR     |           110 | 1994-06-07 |
| Gietz       | AC_ACCOUNT |           110 | 1994-06-07 |
| Faviet      | FI_ACCOUNT |           100 | 1994-08-16 |
| Greenberg   | FI_MGR     |           100 | 1994-08-17 |
…… 
```
```sql
mysql> SELECT last_name job_id, department_id, hire_date
    -> FROM employees
    -> ORDER BY hire_date DESC;
+-------------+---------------+------------+
| job_id      | department_id | hire_date  |
+-------------+---------------+------------+
| Banda       |            80 | 2000-04-21 |
| Kumar       |            80 | 2000-04-21 |
| Ande        |            80 | 2000-03-24 |
| Markle      |            50 | 2000-03-08 |
| Lee         |            80 | 2000-02-23 |
| Philtanker  |            50 | 2000-02-06 |
| Geoni       |            50 | 2000-02-03 |
| Zlotkey     |            80 | 2000-01-29 |
| Marvins     |            80 | 2000-01-24 |
| Grant       |            50 | 2000-01-13 |
| Johnson     |            80 | 2000-01-04 |
……
```
### （2) 多列排序
```sql
mysql> SELECT last_name, department_id, salary
    -> FROM employees
    -> ORDER BY department_id, salary DESC;
+-------------+---------------+----------+
| last_name   | department_id | salary   |
+-------------+---------------+----------+
| Grant       |          NULL |  7000.00 |
| Whalen      |            10 |  4400.00 |
| Hartstein   |            20 | 13000.00 |
| Fay         |            20 |  6000.00 |
| Raphaely    |            30 | 11000.00 |
| Khoo        |            30 |  3100.00 |
| Baida       |            30 |  2900.00 |
| Tobias      |            30 |  2800.00 |
| Himuro      |            30 |  2600.00 |
| Colmenares  |            30 |  2500.00 |
| Mavris      |            40 |  6500.00 |
| Fripp       |            50 |  8200.00 |
| Weiss       |            50 |  8000.00 |
| Kaufling    |            50 |  7900.00 |
| Vollman     |            50 |  6500.00 |
……
```

- 可以使用不在SELECT列表中的列排序。
- 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第 一列数据中所有值都是唯一的，将不再对第二列进行排序。
## 2. 分页
### （1）背景
背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？
背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？
### （2）实现规则

- 分页原理

所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。

- **MySQL中使用 LIMIT 实现分页**
- 格式：
```sql
LIMIT [位置偏移量,] 行数
```
```sql
SELECT column1, column2, ...
FROM table_name
ORDER BY column_name
LIMIT offset, row_count;
```

- offset 指定从哪一行开始返回结果。
- row_count 指定返回多少行。
- 举例：
```sql
SELECT * FROM Employees
ORDER BY EmployeeID
LIMIT 10, 20;
```
这个查询将返回从第21行开始的10行数据（因为 OFFSET 是从0开始计数的）。
> MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。

- 分页显式公式：（当前页数-1）* 每页条数，每页条数

在SQL分页操作中，显式公式通常用于根据当前页码和每页显示的行数来计算查询的 OFFSET 和 LIMIT。分页公式因数据库管理系统（DBMS）的不同而略有差异，但核心思想是相同的。
**通用分页公式**
假设有以下分页参数：
page_number：当前页码，从1开始。
page_size：每页显示的行数。
那么：
OFFSET 的计算公式为：
```sql
OFFSET = (page_number - 1) * page_size
```
LIMIT 的计算公式为：
```sql
LIMIT = page_size
```
举例：
假设当前页码为 page_number = 3，每页显示的行数为 page_size = 10：
```sql
SELECT * FROM Employees
ORDER BY EmployeeID
LIMIT 10 OFFSET 20;  -- OFFSET = (3 - 1) * 10 = 20
```
或者：
```sql
SELECT * FROM Employees
ORDER BY EmployeeID
LIMIT 20, 10;  -- OFFSET = 20, LIMIT = 10
```

-  **注意：LIMIT 子句必须放在整个SELECT语句的最后！ **
-  使用LIMIT的好处 

约束返回结果的数量可以**减少数据表的网络传输量** ，也可以**提升查询效率 **。如果我们知道返回结果只有 1 条，就可以使用**LIMIT 1** ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需 要扫描完整的表，只需要检索到一条符合条件的记录即可返回。
# 第四章 连接查询
SQL中的连接（Join）用于将两个或多个表中的数据结合起来，基于它们之间的相关列。连接操作是SQL查询中最强大的部分之一，能够帮助你在各个表之间关联数据。
## 连接过程简介
我们成功建立了t1、t2两个表，这两个表都有两个列，一个是INT类型的，一个是CHAR(1)类型的，填充好数据的两个表长这样：
```sql
mysql> SELECT * FROM t1;
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM t2;
+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
3 rows in set (0.00 sec)
```
在连接查询中的过滤条件可以分成两种：

- 涉及单表的条件

这种只涉及单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为搜索条件，比如t1.m1 > 1是只针对t1表的过滤条件，t2.n2 < 'd'是只针对t2表的过滤条件。

- 涉及两表的条件

这种过滤条件我们之前没见过，比如t1.m1 = t2.m2、t1.n1 > t2.n2等，这些条件中涉及到了两个表，我们稍后会仔细分析这种过滤条件是如何使用的哈。
下边我们就要看一下携带过滤条件的连接查询的大致执行过程了，比方说下边这个查询语句：
```sql
ini

复制代码SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```
在这个查询中我们指明了这三个过滤条件：

- t1.m1 > 1
- t1.m1 = t2.m2
- t2.n2 < 'd'

那么这个连接查询的大致执行过程如下：

1. 首先确定第一个需要查询的表，这个表称之为驱动表。此处假设使用t1作为驱动表，那么就需要到t1表中找满足t1.m1 > 1的记录，符合这个条件的t1表记录如下所示：
```sql
+------+------+
| m1   | n1   |
+------+------+
|    2 | b    |
|    3 | c    |
+------+------+
2 rows in set (0.01 sec)
```
我们可以看到，t1表中符合t1.m1 > 1的记录有两条。

2. 上一步骤中从驱动表每获取到一条记录，都需要到t2表中查找匹配的记录，所谓匹配的记录，指的是符合过滤条件的记录。因为是根据t1表中的记录去找t2表中的记录，所以t2表也可以被称之为被驱动表。上一步骤从驱动表中得到了2条记录，也就意味着需要查询2次t2表。此时涉及两个表的列的过滤条件t1.m1 = t2.m2就派上用场了：
   - 对于从t1表种查询得到的第一条记录，也就是当t1.m1 = 2, t1.n1 = 'b'时，过滤条件t1.m1 = t2.m2就相当于t2.m2 = 2，所以此时t2表相当于有了t2.m2 = 2、t2.n2 < 'd'这两个过滤条件，然后到t2表中执行单表查询，将得到的记录和从t1表中查询得到的第一条记录相组合得到下边的结果：
```sql
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
+------+------+------+------+
```

   - 对于从t1表种查询得到的第二条记录，也就是当t1.m1 = 3, t1.n1 = 'c'时，过滤条件t1.m1 = t2.m2就相当于t2.m2 = 3，所以此时t2表相当于有了t2.m2 = 3、t2.n2 < 'd'这两个过滤条件，然后到t2表中执行单表查询，将得到的记录和从t1表中查询得到的第二条记录相组合得到下边的结果：
```sql
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    3 | c    |    3 | c    |
+------+------+------+------+
```
所以整个连接查询的执行最后得到的结果集就是这样：
```sql
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)
```
从上边两个步骤可以看出来，我们上边唠叨的这个两表连接查询共需要查询1次t1表，2次t2表。当然这是在特定的过滤条件下的结果，如果我们把t1.m1 > 1这个条件去掉，那么从t1表中查出的记录就有3条，就需要查询3次t2表了。也就是说在两表连接查询中，驱动表只需要查询一次，被驱动表可能会被查询多次。
## 1.等值连接
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717399976805-624fe740-004a-4f12-83e8-b41ac9493b06.png#averageHue=%23ececeb&clientId=uc8550b36-0b85-4&from=paste&height=310&id=ua163ab7d&originHeight=387&originWidth=903&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132071&status=done&style=none&taskId=u0902cfe4-45fa-490f-9653-92faf94d2ef&title=&width=722.4)
### （1）格式

- 加入连接条件后，查询语法：
```sql
SELECT table1.column, table2.column
FROM table1, table2
WHERE table1.column1 = table2.column2;  #连接条件
```

   - **在 WHERE子句中写入连接条件。**
- 正确写法：
```sql
#案例：查询员工的姓名及其部门名称
SELECT last_name, department_name
FROM employees, departments
WHERE employees.department_id = departments.department_id;
```

- **在表中有相同列时，在列名之前加上表名前缀。**
### （2）举例
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717400425340-66ef0b14-1dfe-4cba-a6c2-cce29f751216.png#averageHue=%23f3eeee&clientId=uc8550b36-0b85-4&from=paste&height=339&id=u35b9eeca&originHeight=582&originWidth=902&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=100524&status=done&style=none&taskId=u320dfbcc-31d2-4eca-bc96-734395f081f&title=&width=525)
```sql
mysql> SELECT employees.employee_id, employees.last_name, departments.department_id, departments.location_id
    ->  FROM employees,departments
    -> WHERE employees.department_id = departments.department_id;
+-------------+-------------+---------------+-------------+
| employee_id | last_name   | department_id | location_id |
+-------------+-------------+---------------+-------------+
|         103 | Hunold      |            60 |        1400 |
|         104 | Ernst       |            60 |        1400 |
|         105 | Austin      |            60 |        1400 |
|         106 | Pataballa   |            60 |        1400 |
|         107 | Lorentz     |            60 |        1400 |
|         120 | Weiss       |            50 |        1500 |
|         121 | Fripp       |            50 |        1500 |
|         122 | Kaufling    |            50 |        1500 |
|         123 | Vollman     |            50 |        1500 |
……
```
**拓展1：**多个连接条件用 AND 操作符 连接
**拓展2：**区分重复的列名

- **多个表中有相同列时，必须在列名之前加上表名前缀。**
- 在不同表中具有相同列名的列可以用 表名 加以区分。
```sql
SELECT employees.last_name, departments.department_name,employees.department_id
FROM employees, departments
WHERE employees.department_id = departments.department_id;
```
**拓展3：**表的别名

- 使用别名可以简化查询。
- 列名前使用表名前缀可以提高查询效率。
```sql
SELECT e.employee_id, e.last_name, e.department_id,
   d.department_id, d.location_id
FROM  employees e , departments d
WHERE e.department_id = d.department_id;
```
需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错
> 阿里开发规范 ：
> 【 强制 】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。
> 说明 ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。
> 正例 ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;
> 反例 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出1052 异常：Column 'name' in field list is ambiguous。

**拓展4：**连接多个表
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717401314986-0abbce2f-a7aa-4dde-bbd3-6ab5c9b88687.png#averageHue=%23f4efef&clientId=uc8550b36-0b85-4&from=paste&height=338&id=uf49db4de&originHeight=423&originWidth=930&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=86184&status=done&style=none&taskId=uffb9d751-d972-4fbf-8b9b-d233f6cefc9&title=&width=744)
**总结：连接 n个表,至少需要n-1个连接条件。**比如，连接三个表，至少需要两个连接条件。
## 2.非等值连接
非等值连接（Non-Equi Join）是指连接条件不使用等号（=），而是使用其他比较运算符来连接两个表。常见的非等值运算符包括 >, <, >=, <=, <> 等。这种连接方式在需要复杂条件匹配的场景中非常有用，如范围查询、模糊匹配等。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717401979039-a92e5dfc-f261-4c70-8fb2-45b74b5b691d.png#averageHue=%23f2eeee&clientId=uc8550b36-0b85-4&from=paste&height=379&id=u825c85e4&originHeight=527&originWidth=901&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=123666&status=done&style=none&taskId=u9552ffc5-56da-4609-96d1-10d2dc9468d&title=&width=648)
```sql
mysql> SELECT e.last_name,e.salary,j.grade_level
    -> FROM employees e,job_grades j
    -> WHERE e.`salary` >= j.`lowest_sal` AND e.`salary` <= j.`highest_sal`;
+-------------+----------+-------------+
| last_name   | salary   | grade_level |
+-------------+----------+-------------+
| King        | 24000.00 | E           |
| Kochhar     | 17000.00 | E           |
| De Haan     | 17000.00 | E           |
| Hunold      |  9000.00 | C           |
| Ernst       |  6000.00 | C           |
| Austin      |  4800.00 | B           |
| Pataballa   |  4800.00 | B           |
| Lorentz     |  4200.00 | B           |
| Greenberg   | 12000.00 | D           |
| Faviet      |  9000.00 | C           |
| Chen        |  8200.00 | C           |
| Sciarra     |  7700.00 | C           |
| Urman       |  7800.00 | C           |
| Popp        |  6900.00 | C           |
| Raphaely    | 11000.00 | D           |
……
```
## 3.自连接
《[MySQL 是怎样使用的：从零蛋开始学习 MySQL](https://juejin.cn/book/6844733802426662926/section)》
我们上边说的都是多个不同的表之间的连接，其实同一个表也可以进行连接。比方说我们可以对两个t1表来生成笛卡尔积，就像这样：
```sql
mysql> SELECT * FROM t1, t1;
ERROR 1066 (42000): Not unique table/alias: 't1'
mysql>
```
咦，报了个错，这是因为设计MySQL的大叔不允许FROM子句中出现相同的表名。我们这里需要的是两张一模一样的t1表进行连接，为了把两个一样的表区分一下，需要为表定义别名。比如这样：
```sql
mysql> SELECT * FROM t1 AS table1, t1 AS table2;
+------+------+------+------+
| m1   | n1   | m1   | n1   |
+------+------+------+------+
|    1 | a    |    1 | a    |
|    2 | b    |    1 | a    |
|    3 | c    |    1 | a    |
|    1 | a    |    2 | b    |
|    2 | b    |    2 | b    |
|    3 | c    |    2 | b    |
|    1 | a    |    3 | c    |
|    2 | b    |    3 | c    |
|    3 | c    |    3 | c    |
+------+------+------+------+
9 rows in set (0.00 sec)

mysql>
```
这里相当于我们为t1表定义了两个副本，一个是table1，另一个是table2，这里的连接过程就不赘述了，大家把它们认为是不同的表就好了。由于被连接的表其实是源自同一个表，所以这种连接也称为自连接。我们看一下这个自连接的现实意义，比方说我们想查看与'史珍香'相同专业的学生有哪些，可以这么写：
```sql
mysql> SELECT s2.number, s2.name, s2.major FROM student_info AS s1 INNER JOIN student_info AS s2 WHERE s1.major = s2.major AND s1.name = '史珍香' ;
+----------+-----------+--------------+
| number   | name      | major        |
+----------+-----------+--------------+
| 20180103 | 范统      | 软件工程     |
| 20180104 | 史珍香    | 软件工程     |
+----------+-----------+--------------+
2 rows in set (0.01 sec)

mysql>
```
s1、s2都可以看作是student_info表的一份副本，我们可以这样理解这个查询：

- 根据s1.name = '史珍香'搜索条件过滤s1表，可以得到该同学的基本信息：
```sql
+----------+-----------+------+--------------------+-----------------+--------------+-----------------+
| number   | name      | sex  | id_number          | department      | major        | enrollment_time |
+----------+-----------+------+--------------------+-----------------+--------------+-----------------+
| 20180104 | 史珍香    | 女   | 141992199701078600 | 计算机学院      | 软件工程     | 2018-09-01      |
+----------+-----------+------+--------------------+-----------------+--------------+-----------------+
```

- 因为通过查询s1表，得到了'史珍香'所在的专业其实是'软件工程'，接下来就应该查询s2表了，查询s2表的时候的过滤条件s1.major = s2.major就相当于s2.major = '软件工程'，于是查询到2条记录：
```sql
+----------+-----------+------+--------------------+-----------------+--------------+-----------------+
| number   | name      | sex  | id_number          | department      | major        | enrollment_time |
+----------+-----------+------+--------------------+-----------------+--------------+-----------------+
| 20180103 | 范统      | 男   | 17156319980116959X | 计算机学院      | 软件工程     | 2018-09-01      |
| 20180104 | 史珍香    | 女   | 141992199701078600 | 计算机学院      | 软件工程     | 2018-09-01      |
+----------+-----------+------+--------------------+-----------------+--------------+-----------------+
```
而我们只需要s2表的number、name、major这3个列的数据，所以最终的结果就长这样：
```sql
+----------+-----------+--------------+
| number   | name      | major        |
+----------+-----------+--------------+
| 20180103 | 范统      | 软件工程     |
| 20180104 | 史珍香    | 软件工程     |
+----------+-----------+--------------+
```
## 4.内连接
student_info表和student_score表
```sql
mysql> INSERT INTO student_info(number, name, sex, id_number, department, major, enrollment_time) VALUES
    ->     (20180101, '杜子腾', '男', '158177199901044792', '计算机学院', '计算机科学与工程', '2018-09-01'),
    ->     (20180102, '杜琦燕', '女', '151008199801178529', '计算机学院', '计算机科学与工程', '2018-09-01'),
    ->     (20180103, '范统', '男', '17156319980116959X', '计算机学院', '软件工程', '2018-09-01'),
    ->     (20180104, '史珍香', '女', '141992199701078600', '计算机学院', '软件工程', '2018-09-01'),
    ->     (20180105, '范剑', '男', '181048199308156368', '航天学院', '飞行器设计', '2018-09-01'),
    ->     (20180106, '朱逸群', '男', '197995199501078445', '航天学院', '电子信息', '2018-09-01');
Query OK, 6 rows affected (0.01 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql> INSERT INTO student_score (number, subject, score) VALUES
    ->     (20180101, '母猪的产后护理', 78),
    ->     (20180101, '论萨达姆的战争准备', 88),
    ->     (20180102, '母猪的产后护理', 100),
    ->     (20180102, '论萨达姆的战争准备', 98),
    ->     (20180103, '母猪的产后护理', 59),
    ->     (20180103, '论萨达姆的战争准备', 61),
    ->     (20180104, '母猪的产后护理', 55),
    ->     (20180104, '论萨达姆的战争准备', 46);
Query OK, 8 rows affected (0.00 sec)
Records: 8  Duplicates: 0  Warnings: 0

mysql>

```
了解了连接查询的执行过程之后，视角再回到我们的student_info表和student_score表。现在我们想在一个查询语句中既查询到学生的基本信息，也查询到学生的成绩信息，就需要进行两表连接了。连接过程就是从student_info表中取出记录，在student_score表中查找number值相同的成绩记录，所以过滤条件就是student_info.number = student_score.number，整个查询语句就是这样：
```sql
mysql> SELECT student_info.number, name, major, subject, score FROM student_info, student_score WHERE student_info.number = student_score.number;
+----------+-----------+--------------------------+-----------------------------+-------+
| number   | name      | major                    | subject                     | score |
+----------+-----------+--------------------------+-----------------------------+-------+
| 20180101 | 杜子腾    | 计算机科学与工程         | 母猪的产后护理              |    78 |
| 20180101 | 杜子腾    | 计算机科学与工程         | 论萨达姆的战争准备          |    88 |
| 20180102 | 杜琦燕    | 计算机科学与工程         | 母猪的产后护理              |   100 |
| 20180102 | 杜琦燕    | 计算机科学与工程         | 论萨达姆的战争准备          |    98 |
| 20180103 | 范统      | 软件工程                 | 母猪的产后护理              |    59 |
| 20180103 | 范统      | 软件工程                 | 论萨达姆的战争准备          |    61 |
| 20180104 | 史珍香    | 软件工程                 | 母猪的产后护理              |    55 |
| 20180104 | 史珍香    | 软件工程                 | 论萨达姆的战争准备          |    46 |
+----------+-----------+--------------------------+-----------------------------+-------+
8 rows in set (0.00 sec)

mysql>
```
```sql
小贴士：

student_info表和student_score表都有number列，不过我们在上述查询语句的查询列表中只放置了student_info表的number列，这是因为我们的过滤条件是student_info.number = student_score.number，从两个表中取出的记录的number列都相同，所以只需要放置一个表中的number列到查询列表即可，也就是说我们把student_score.number放到查询列表处也是可以滴～
```
从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题，范剑和朱逸群同学，也就是学号为20180105和20180106的同学因为某些原因没有参加考试，所以在studnet_score表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的连接查询是无法完成这样的需求的。我们稍微思考一下这个需求，其本质是想：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。为了解决这个问题，就有了内连接和外连接的概念：

- 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。
- 对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

在MySQL中，根据选取驱动表的不同，外连接仍然可以细分为2种：

   - 左外连接

选取左侧的表为驱动表。

   - 右外连接

选取右侧的表为驱动表。
如果是左外连接，则连接条件中左边的表也称为** 主表 **，右边的表称为 **从表 **。
如果是右外连接，则连接条件中右边的表也称为 **主表 **，左边的表称为** 从表** 。
可是这样仍然存在问题，即使对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。这就犯难了，有时候匹配失败要加入结果集，有时候又不要加入结果集，这咋办，有点儿愁啊。。。噫，把过滤条件分为两种不就解决了这个问题了么，所以放在不同地方的过滤条件是有不同语义的：

- WHERE子句中的过滤条件

WHERE子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合WHERE子句中的过滤条件的记录都不会被加入最后的结果集。

- ON子句中的过滤条件

对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充。
需要注意的是，这个ON子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把ON子句放到内连接中，MySQL会把它和WHERE子句一样对待，也就是说：内连接中的WHERE子句和ON子句是等价的。
一般情况下，我们都把只涉及单表的过滤条件放到WHERE子句中，把涉及两表的过滤条件都放到ON子句中，我们也一般把放到ON子句中的过滤条件也称之为连接条件。
## 5.SQL99语法实现多表查询
### （1）基本语法

- 使用JOIN...ON子句创建连接的语法结构：
```sql
SELECT table1.column, table2.column,table3.column
FROM table1
  JOIN table2 ON table1 和 table2 的连接条件
    JOIN table3 ON table2 和 table3 的连接条件 
```
它的嵌套逻辑类似我们使用的 FOR 循环：
```sql
for t1 in table1:
  for t2 in table2:
   if condition1:
     for t3 in table3:
       if condition2:
        output t1 + t2 + t3
```
SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。

- 语法说明：
   - **可以使用 ON 子句指定额外的连接条件。**
   - 这个连接条件是与其它条件分开的。
   - **ON 子句使语句具有更高的易读性。**
   - 关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接
### （2）内连接（INNER JOIN）的实现

- 语法
```sql
SELECT 字段列表
FROM A表 INNER JOIN B表
ON 关联条件
WHERE 等其他子句;
```
```sql
#在MySQL中，下边这几种内连接的写法都是等价的：
SELECT * FROM t1 JOIN t2;
SELECT * FROM t1 INNER JOIN t2;
SELECT * FROM t1 CROSS JOIN t2;
```
示例场景
假设我们有两个表：Customers 和 Orders。Customers 表记录了客户的详细信息，而 Orders 表记录了订单的信息。
**Customers** 表：

| CustomerID | CustomerName | ContactName | Country |
| --- | --- | --- | --- |
| 1 | Alfreds Futterkiste | Maria Anders | Germany |
| 2 | Ana Trujillo Emparedados y helados | Ana Trujillo | Mexico |
| 3 | Antonio Moreno Taquería | Antonio Moreno | Mexico |

**Orders** 表：

| OrderID | CustomerID | OrderDate |
| --- | --- | --- |
| 10308 | 2 | 2023-01-15 |
| 10309 | 1 | 2023-01-16 |
| 10310 | 3 | 2023-01-17 |
| 10311 | 4 | 2023-01-18 |

我们希望查询每个订单及其对应的客户信息，可以使用 INNER JOIN：
```sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers
ON Orders.CustomerID = Customers.CustomerID;
```
结果

| OrderID | CustomerName | OrderDate |
| --- | --- | --- |
| 10308 | Ana Trujillo Emparedados y helados | 2023-01-15 |
| 10309 | Alfreds Futterkiste | 2023-01-16 |
| 10310 | Antonio Moreno Taquería | 2023-01-17 |

注意，OrderID 为 10311 的订单没有出现在结果集中，因为 Customers 表中没有 CustomerID 为 4 的记录。
**INNER JOIN 的使用场景**
**1. 多个连接条件**
可以在 INNER JOIN 中使用多个连接条件，例如：
```sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers
ON Orders.CustomerID = Customers.CustomerID
AND Customers.Country = 'Mexico';
```
结果

| OrderID | CustomerName | OrderDate |
| --- | --- | --- |
| 10308 | Ana Trujillo Emparedados y helados | 2023-01-15 |
| 10310 | Antonio Moreno Taquería | 2023-01-17 |

**2. 内连接多个表**
可以在同一个查询中内连接多个表，例如：
假设我们有第三个表 Products，它记录了每个订单的产品信息。
Products 表：

| ProductID | ProductName | OrderID |
| --- | --- | --- |
| 1 | Apples | 10308 |
| 2 | Bananas | 10309 |
| 3 | Cherries | 10310 |

我们希望查询所有订单、客户及产品信息：
```sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate, Products.ProductName
FROM Orders
INNER JOIN Customers
ON Orders.CustomerID = Customers.CustomerID
INNER JOIN Products
ON Orders.OrderID = Products.OrderID;
```
结果

| OrderID | CustomerName | OrderDate | ProductName |
| --- | --- | --- | --- |
| 10308 | Ana Trujillo Emparedados y helados | 2023-01-15 | Apples |
| 10309 | Alfreds Futterkiste | 2023-01-16 | Bananas |
| 10310 | Antonio Moreno Taquería | 2023-01-17 | Cherries |

### （3）外连接（OUTER JOIN）的实现
#### ①左外连接（LEFT OUTER JOIN）
左外连接（Left Outer Join），简称 `LEFT JOIN`，是 SQL 中用于连接两个表的一种方式。它会返回左表中的所有行，以及右表中符合连接条件的行。如果左表中的某一行在右表中没有匹配项，结果集中右表的列将包含 `NULL`。这种连接方式确保了左表的所有记录都会出现在结果集中，无论其在右表中是否有匹配。

- 语法：
```sql
#实现查询结果是A
SELECT 字段列表
FROM A表 LEFT JOIN B表
ON 关联条件
WHERE 等其他子句;
```

- 示例场景

假设我们有两个表：`Customers` 和 `Orders`。`Customers` 表记录了客户的详细信息，而 `Orders` 表记录了订单的信息。
**Customers** 表：

| CustomerID | CustomerName | ContactName | Country |
| --- | --- | --- | --- |
| 1 | Alfreds Futterkiste | Maria Anders | Germany |
| 2 | Ana Trujillo Emparedados y helados | Ana Trujillo | Mexico |
| 3 | Antonio Moreno Taquería | Antonio Moreno | Mexico |
| 4 | Around the Horn | Thomas Hardy | UK |

**Orders** 表：

| OrderID | CustomerID | OrderDate |
| --- | --- | --- |
| 10308 | 2 | 2023-01-15 |
| 10309 | 1 | 2023-01-16 |
| 10310 | 3 | 2023-01-17 |

我们希望查询每个客户及其订单信息，即使有些客户没有订单，也会显示其信息：
```sql
SELECT Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.OrderDate
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID = Orders.CustomerID;
```
结果

| CustomerID | CustomerName | OrderID | OrderDate |
| --- | --- | --- | --- |
| 1 | Alfreds Futterkiste | 10309 | 2023-01-16 |
| 2 | Ana Trujillo Emparedados y helados | 10308 | 2023-01-15 |
| 3 | Antonio Moreno Taquería | 10310 | 2023-01-17 |
| 4 | Around the Horn | NULL | NULL |

在这个结果中，客户 `Around the Horn` 没有订单记录，但是仍然出现在结果集中，且其订单信息列为 `NULL`。

- **LEFT JOIN 的使用场景**
   - **处理缺失数据**

左外连接常用于处理缺失数据。例如，查询所有客户及其订单信息，即使某些客户没有订单：
```sql
SELECT Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.OrderDate
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID = Orders.CustomerID;
```

   - 统计信息

可以使用左外连接来统计信息，例如，查询每个客户的订单数量：
```sql
SELECT Customers.CustomerID, Customers.CustomerName, COUNT(Orders.OrderID) AS OrderCount
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID = Orders.CustomerID
GROUP BY Customers.CustomerID, Customers.CustomerName;
```
结果

| CustomerID | CustomerName | OrderCount |
| --- | --- | --- |
| 1 | Alfreds Futterkiste | 1 |
| 2 | Ana Trujillo Emparedados y helados | 1 |
| 3 | Antonio Moreno Taquería | 1 |
| 4 | Around the Horn | 0 |

3. 多个连接条件
可以在左外连接中使用多个连接条件。例如，假设我们有一个 `Products` 表，记录了每个订单的产品信息：
**Products** 表：

| ProductID | ProductName | OrderID |
| --- | --- | --- |
| 1 | Apples | 10308 |
| 2 | Bananas | 10309 |
| 3 | Cherries | 10310 |

我们希望查询每个客户及其订单和产品信息，即使某些客户没有订单或某些订单没有产品：
```sql
SELECT Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.OrderDate, Products.ProductName
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID = Orders.CustomerID
LEFT JOIN Products
ON Orders.OrderID = Products.OrderID;
```
结果

| CustomerID | CustomerName | OrderID | OrderDate | ProductName |
| --- | --- | --- | --- | --- |
| 1 | Alfreds Futterkiste | 10309 | 2023-01-16 | Bananas |
| 2 | Ana Trujillo Emparedados y helados | 10308 | 2023-01-15 | Apples |
| 3 | Antonio Moreno Taquería | 10310 | 2023-01-17 | Cherries |
| 4 | Around the Horn | NULL | NULL | NULL |

#### ②右外连接(RIGHT OUTER JOIN)
右外连接（Right Outer Join），简称 `RIGHT JOIN`，是 SQL 中用于连接两个表的一种方式。它会返回右表中的所有行，以及左表中符合连接条件的行。如果右表中的某一行在左表中没有匹配项，结果集中左表的列将包含 `NULL`。这种连接方式确保右表的所有记录都会出现在结果集中，无论其在左表中是否有匹配。

- 语法
```sql
#实现查询结果是B
SELECT 字段列表
FROM A表 LEFT JOIN B表
ON 关联条件
WHERE 等其他子句;
```

- 示例场景

假设我们有两个表：`Employees` 和 `Departments`。`Employees` 表记录了员工的详细信息，而 `Departments` 表记录了部门的信息。
**Employees** 表：

| EmployeeID | EmployeeName | DepartmentID |
| --- | --- | --- |
| 1 | Alice | 101 |
| 2 | Bob | 102 |
| 3 | Charlie | 101 |
| 4 | David | 103 |

**Departments** 表：

| DepartmentID | DepartmentName |
| --- | --- |
| 101 | IT |
| 102 | HR |
| 103 | Finance |
| 104 | Marketing |

我们希望查询每个部门及其员工信息，即使有些部门没有员工，也会显示其信息：
```sql
SELECT Employees.EmployeeID, Employees.EmployeeName, Departments.DepartmentID, Departments.DepartmentName
FROM Employees
RIGHT JOIN Departments
ON Employees.DepartmentID = Departments.DepartmentID;
```
结果

| EmployeeID | EmployeeName | DepartmentID | DepartmentName |
| --- | --- | --- | --- |
| 1 | Alice | 101 | IT |
| 3 | Charlie | 101 | IT |
| 2 | Bob | 102 | HR |
| 4 | David | 103 | Finance |
| NULL | NULL | 104 | Marketing |

在这个结果中，`DepartmentID` 为 104 的部门没有员工记录，但仍然出现在结果集中，且其员工信息列为 `NULL`。

- RIGHT JOIN 的使用场景
   - 查询所有右表记录及其相关左表记录

右外连接常用于确保右表中的所有记录都会出现在结果集中，即使没有匹配的左表记录。例如，查询所有部门及其员工信息：
```sql
SELECT Employees.EmployeeID, Employees.EmployeeName, Departments.DepartmentID, Departments.DepartmentName
FROM Employees
RIGHT JOIN Departments
ON Employees.DepartmentID = Departments.DepartmentID;
```

   - 处理缺失数据

右外连接可以用于处理右表中有记录但左表中没有匹配记录的数据。假设我们有一个 `Projects` 表，记录了每个部门的项目信息：
**Projects** 表：

| ProjectID | ProjectName | DepartmentID |
| --- | --- | --- |
| 1 | Project A | 101 |
| 2 | Project B | 102 |
| 3 | Project C | 103 |

我们希望查询每个部门及其项目信息，即使某些部门没有项目：
```sql
SELECT Departments.DepartmentID, Departments.DepartmentName, Projects.ProjectID, Projects.ProjectName
FROM Projects
RIGHT JOIN Departments
ON Projects.DepartmentID = Departments.DepartmentID;
```
结果

| DepartmentID | DepartmentName | ProjectID | ProjectName |
| --- | --- | --- | --- |
| 101 | IT | 1 | Project A |
| 102 | HR | 2 | Project B |
| 103 | Finance | 3 | Project C |
| 104 | Marketing | NULL | NULL |

   - 多个连接条件

可以在右外连接中使用多个连接条件。例如，假设我们有一个 `Managers` 表，记录了每个部门的经理信息：
**Managers** 表：

| ManagerID | ManagerName | DepartmentID |
| --- | --- | --- |
| 1 | John | 101 |
| 2 | Sarah | 102 |
| 3 | Mike | 103 |

我们希望查询每个部门及其经理和员工信息，即使某些部门没有经理或员工：
```sql
SELECT Departments.DepartmentID, Departments.DepartmentName, Managers.ManagerName, Employees.EmployeeName
FROM Departments
RIGHT JOIN Managers
ON Departments.DepartmentID = Managers.DepartmentID
LEFT JOIN Employees
ON Departments.DepartmentID = Employees.DepartmentID;
```
结果

| DepartmentID | DepartmentName | ManagerName | EmployeeName |
| --- | --- | --- | --- |
| 101 | IT | John | Alice |
| 101 | IT | John | Charlie |
| 102 | HR | Sarah | Bob |
| 103 | Finance | Mike | David |
| 104 | Marketing | NULL | NULL |

> 需要注意的是，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，只能用 (+) 表示。

### （4）满外连接(FULL OUTER JOIN)

- 满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。
- SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。
- 需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN **UNION** RIGHT join代替。
## 6. UNION的使用
UNION 是 SQL 中的一种操作符，用于合并两个或更多的 SELECT 语句的结果集。UNION 操作符会默认去除重复的记录，如果需要保留重复记录，可以使用 UNION ALL。所有 SELECT 语句必须具有相同数量的列，列的数据类型也必须兼容。
**语法格式：**
```sql
SELECT column,... FROM table1
UNION [ALL]
SELECT column,... FROM table2
```
**合并查询的规则**

1. **列数相同**：合并的所有 SELECT 语句必须返回相同数量的列。
2. **列类型兼容**：合并的所有 SELECT 语句中对应列的数据类型必须兼容。
3. **列顺序相同**：合并的所有 SELECT 语句中列的顺序必须相同。

**UNION操作符**
UNION 操作符返回两个查询的结果集的并集，去除重复记录。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717413462233-682affae-b732-4e40-93cf-4c456653af66.png#averageHue=%23fcfc9b&clientId=uc8550b36-0b85-4&from=paste&height=166&id=u4256a951&originHeight=243&originWidth=564&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17382&status=done&style=none&taskId=u130d12d8-0484-4b5a-9bfa-9b03284fd13&title=&width=384.20001220703125)
**UNION ALL操作符**
UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717413494907-a81b530a-f3ea-479e-8ac0-f1c7e09f9d23.png#averageHue=%23fcfca2&clientId=uc8550b36-0b85-4&from=paste&height=239&id=u7d0a0886&originHeight=321&originWidth=551&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25571&status=done&style=none&taskId=u0a222d8c-fd26-4ee1-ac3f-994471517cc&title=&width=409.8000183105469)
> 注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。

举例：查询部门编号>90或邮箱包含a的员工信息
```sql
#方式1
SELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90;
```
```sql
#方式2
SELECT * FROM employees WHERE email LIKE '%a%'
UNION
SELECT * FROM employees WHERE department_id>90;
```
举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息
```sql
SELECT id,cname FROM t_chinamale WHERE csex='男'
UNION ALL
SELECT id,tname FROM t_usmale WHERE tGender='male';
```
## 7.七种SQL JOINS的实现
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717413949338-36339def-2aff-40fe-8a4a-30c57cda6b0e.png#averageHue=%23e6c7c7&clientId=uc8550b36-0b85-4&from=paste&height=681&id=ua9ecbb3b&originHeight=851&originWidth=1161&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=650988&status=done&style=none&taskId=u916b01d4-eab8-4677-a476-6cf313966b6&title=&width=928.8)
### (1)代码实现
```sql
# 中图：内连接
SELECT employee_id,department_name
FROM employees e JOIN departments d
ON e.`department_id` = d.`department_id`;

# 左上图：左外连接
SELECT employee_id,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`;

# 右上图：右外连接
SELECT employee_id,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`;

# 左中图：
SELECT employee_id,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE d.`department_id` IS NULL;

# 右中图：
SELECT employee_id,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE e.`department_id` IS NULL;


# 左下图：满外连接
# 方式1：左上图 UNION ALL 右中图
SELECT employee_id,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`
UNION ALL
SELECT employee_id,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE e.`department_id` IS NULL;


# 方式2：左中图 UNION ALL 右上图
SELECT employee_id,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE d.`department_id` IS NULL
UNION ALL
SELECT employee_id,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`;

# 右下图：左中图  UNION ALL 右中图
SELECT employee_id,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE d.`department_id` IS NULL
UNION ALL
SELECT employee_id,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE e.`department_id` IS NULL;
```
### （2）语法格式小结

- 左中图
```sql
#实现A - A∩B
select 字段列表
from A表 left join B表
on 关联条件
where 从表关联字段 is null and 等其他子句;
```

- 右中图
```sql
#实现B - A∩B
select 字段列表
from A表 right join B表
on 关联条件
where 从表关联字段 is null and 等其他子句;
```

- 左下图
```sql
#实现查询结果是A∪B
#用左外的A，union 右外的B
select 字段列表
from A表 left join B表
on 关联条件
where 等其他子句
union
select 字段列表
from A表 right join B表
on 关联条件
where 等其他子句;
#实现A∪B - A∩B 或  (A - A∩B) ∪ （B - A∩B）
#使用左外的 (A - A∩B) union 右外的（B - A∩B）
select 字段列表
from A表 left join B表
on 关联条件
where 从表关联字段 is null and 等其他子句
union
select 字段列表
from A表 right join B表
on 关联条件
where 从表关联字段 is null and 等其他子句
```
## 8. SQL99语法的新特性
### （1) 自然连接
SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 NATURAL JOIN 用来表示自然连接。我们可以把 自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行等值连接 。
在SQL92标准中：
```sql
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
ON e.`department_id` = d.`department_id`
AND e.`manager_id` = d.`manager_id`;
```
在 SQL99 中你可以写成：
```sql
SELECT employee_id,last_name,department_name
FROM employees e NATURAL JOIN departments d;
```
### （2) USING连接
当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配 合JOIN一起使用。比如：
```sql
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
USING (department_id);
```
你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 JOIN...USING 可以简化 JOIN ON 的等值连接。它与下 面的 SQL 查询结果是相同的：
```sql
SELECT employee_id,last_name,department_name
FROM employees e ,departments d
WHERE e.department_id = d.department_id;
```
## 9. 小结
表连接的约束条件可以有三种方式：WHERE, ON, USING

- WHERE：适用于所有关联查询
- ON ：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起 写，但分开写可读性更好。
- USING：只能和JOIN一起使用，而且要求**两个**关联字段在关联表中名称一致，而且只能表示关联字段值相等（下面是解释）

为什么USING的关联字段值要相等？
在SQL中，当使用USING关键字进行连接操作时，要求连接两个表的关联字段（即指定的列）的值在两个表中是相等的。这意味着，只有在连接的列的值在两个表中完全相同的情况下，这两行记录才会被连接起来形成结果集。
举个例子，假设有一个学生表（students）和一个课程表（courses），它们具有一个共同的列student_id，用于指示学生和他们所选的课程。如果我们想根据student_id连接这两个表，可以使用USING关键字进行连接：
```sql
SELECT students.student_id, students.name, courses.course_name
FROM students
INNER JOIN courses
USING (student_id);
```
在这个例子中，连接操作会通过student_id这个共同列将学生表和课程表进行连接。USING关键字要求student_id列的值在两个表中相等，只有当学生表中的student_id值与课程表中相同的student_id值匹配时，这两个表的记录才会被连接起来，形成最终的结果集。
因此，使用USING关键字进行连接时，关联字段的值相等这一要求是必须满足的条件，以确保连接操作能够正确地将相关的记录匹配起来。
```sql
#关联条件
#把关联条件写在where后面
SELECT last_name,department_name
FROM employees,departments
WHERE employees.department_id = departments.department_id;
#把关联条件写在on后面，只能和JOIN一起使用
SELECT last_name,department_name
FROM employees INNER JOIN departments
ON employees.department_id = departments.department_id;
SELECT last_name,department_name
FROM employees CROSS JOIN departments
ON employees.department_id = departments.department_id;
SELECT last_name,department_name 
FROM employees JOIN departments
ON employees.department_id = departments.department_id;
#把关联字段写在using()中，只能和JOIN一起使用
#而且两个表中的关联字段必须名称相同，而且只能表示=
#查询员工姓名与基本工资
SELECT last_name,job_title
FROM employees INNER JOIN jobs USING(job_id);
#n张表关联，需要n-1个关联条件
#查询员工姓名，基本工资，部门名称
SELECT last_name,job_title,department_name FROM employees,departments,jobs
WHERE employees.department_id = departments.department_id
AND employees.job_id = jobs.job_id;
SELECT last_name,job_title,department_name
FROM employees INNER JOIN departments INNER JOIN jobs
ON employees.department_id = departments.department_id
AND employees.job_id = jobs.job_id;
```
**注意：**
我们要 控制连接表的数量 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。
> 【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保
> 证被关联的字段需要有索引。
> 说明：即使双表 join 也要注意表索引、SQL 性能。
> 来源：阿里巴巴《Java开发手册》

# 第五章 单行函数
## 1.函数的理解
### （1）什么是函数
函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既 提高了代码效率 ，又 提高了可维护性 。在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地 提高用户对数据库的管理效率 。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717417769707-b504d6ef-8749-41e0-9465-34188815af35.png#averageHue=%23f9e9da&clientId=uc8550b36-0b85-4&from=paste&height=336&id=uf3d567f6&originHeight=521&originWidth=878&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=69087&status=done&style=none&taskId=u14a6d0f1-9bf6-49f9-97a2-19940e11eae&title=&width=566.4000244140625)
从函数定义的角度出发，我们可以将函数分成 内置函数 和 自定义函数 。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的，本章及下一章讲解的是 SQL 的内置函数。
### （2）不同DBMS函数的差异
我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即DBMS。**DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异**。实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。大部分 DBMS 会有自己特定的函数，这就意味着**采用 SQL 函数的代码可移植性是很差的**，因此在使用函数的时候需要特别注意。
MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。
MySQL提供的内置函数从 实现的功能角度 可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类： 单行函数 、 聚合函数（或分组函数） 。
**两张SQL函数**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717418528257-0e41af38-6e25-4fa6-8b51-ea82b0e55361.png#averageHue=%23fbece2&clientId=uc8550b36-0b85-4&from=paste&height=188&id=u55059ea3&originHeight=368&originWidth=936&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33969&status=done&style=none&taskId=ubfc73402-81c4-4bfc-9434-8e2bcc95a27&title=&width=479)
**单行函数**

- 操作数据对象
- 接受参数返回一个结果
- **只对一行进行变换**
- **每行返回一个结果**
- 可以嵌套
- 参数可以是一列或一个值
## 2. 数值函数
### （1) 基本函数
| 函数 | 用法 |
| --- | --- |
| ABS(x) | 返回x的绝对值 |
| SIGN(X) | 返回x的符号。正数返回1，负数返回-1,0返回0 |
| PI() | 返回圆周率的值 |
| CEIL(x)，CEILING(x) | 返回大于或等于某个值的最小整数 |
| FLOOR(x) | 返回小于或等于某个值的最大整数 |
| LEAST(e1,e2,e3…) | 返回列表中的最小值 |
| GREATEST(e1,e2,e3…) | 返回列表中的最大值 |
| MOD(x,y) | 返回X除以Y后的余数 |
| RAND() | 返回0~1的随机值 |
| RAND(x) | 返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机 数 |
| ROUND(x) | 返回一个对x的值进行四舍五入后，最接近于X的整数 |
| ROUND(x,y) | 返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位 |
| TRUNCATE(x,y) | 返回数字x截断为y位小数的结果 |
| SQRT(x) | 返回x的平方根。当X的值为负数时，返回NULL |

举例：
```sql
mysql> SELECT
    -> ABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),
    -> FLOOR(-43.23),MOD(12,5)
    -> FROM DUAL;
+-----------+---------+-----------+----------+----------+-------------+-----------------+--------------+---------------+-----------+
| ABS(-123) | ABS(32) | SIGN(-23) | SIGN(43) | PI()     | CEIL(32.32) | CEILING(-43.23) | FLOOR(32.32) | FLOOR(-43.23) | MOD(12,5) |
+-----------+---------+-----------+----------+----------+-------------+-----------------+--------------+---------------+-----------+
|       123 |      32 |        -1 |        1 | 3.141593 |          33 |             -43 |           32 |           -44 |         2 |
+-----------+---------+-----------+----------+----------+-------------+-----------------+--------------+---------------+-----------+
1 row in set (0.01 sec)
```
```sql
mysql> SELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1);
    -> FROM DUAL;
+---------------------+---------------------+--------------------+--------------------+--------------------+--------------------+
| RAND()              | RAND()              | RAND(10)           | RAND(10)           | RAND(-1)           | RAND(-1)           |
+---------------------+---------------------+--------------------+--------------------+--------------------+--------------------+
| 0.10660497947279828 | 0.31308889604461276 | 0.6570515219653505 | 0.6570515219653505 | 0.9050373219931845 | 0.9050373219931845 |
+---------------------+---------------------+--------------------+--------------------+--------------------+--------------------+
1 row in set (0.00 sec)
```
```sql
mysql> SELECT
    -> ROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1)
    -> FROM DUAL;
+--------------+-----------------+------------------+-------------------+--------------------+
| ROUND(12.33) | ROUND(12.343,2) | ROUND(12.324,-1) | TRUNCATE(12.66,1) | TRUNCATE(12.66,-1) |
+--------------+-----------------+------------------+-------------------+--------------------+
|           12 |           12.34 |               10 |              12.6 |                 10 |
+--------------+-----------------+------------------+-------------------+--------------------+
1 row in set (0.01 sec)
```
### 2) 角度与弧度互换函数
| 函数 | 用法 |
| --- | --- |
| RADIANS(x) | 将角度转化为弧度，其中，参数x为角度值 |
| DEGREES(x) | 将弧度转化为角度，其中，参数x为弧度值 |

```sql
mysql> SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90))
    -> FROM DUAL;
+--------------------+--------------------+--------------------+-----------------+----------------------+
| RADIANS(30)        | RADIANS(60)        | RADIANS(90)        | DEGREES(2*PI()) | DEGREES(RADIANS(90)) |
+--------------------+--------------------+--------------------+-----------------+----------------------+
| 0.5235987755982988 | 1.0471975511965976 | 1.5707963267948966 |             360 |                   90 |
+--------------------+--------------------+--------------------+-----------------+----------------------+
1 row in set (0.00 sec)
```
### （3) 三角函数
| 函数 | 用法 |
| --- | --- |
| SIN(x) | 将角度转化为弧度，其中，参数x为角度值 |
| ASIN(x) | 将弧度转化为角度，其中，参数x为弧度值 |
| COS(x) | 返回x的余弦值，其中，参数x为弧度值 |
| ACOS(x) | 返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL |
| TAN(x) | 返回x的正切值，其中，参数x为弧度值 |
| ATAN(x) | 返回x的反正切值，即返回正切值为x的值 |
| ATAN2(m,n) | 返回两个参数的反正切值 |
| COT(x) | 返回x的余切值，其中，X为弧度值 |

举例：
ATAN2(M,N)函数返回两个参数的反正切值。 与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)/(x2-x1))，使用ATAN2(M,N)计算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而ATAN2(M,N)函数则仍然可以计算。
ATAN2(M,N)函数的使用示例如下：
```sql
mysql> SELECT
    -> SIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1)
    -> )
    -> FROM DUAL;
+---------------------+------------------+--------------------+------------------+----------------------+
| SIN(RADIANS(30))    | DEGREES(ASIN(1)) | TAN(RADIANS(45))   | DEGREES(ATAN(1)) | DEGREES(ATAN2(1,1)
) |
+---------------------+------------------+--------------------+------------------+----------------------+
| 0.49999999999999994 |               90 | 0.9999999999999999 |               45 |                   45 |
+---------------------+------------------+--------------------+------------------+----------------------+
1 row in set (0.01 sec)
```
### （4) 指数与对数函数
| 函数 | 用法 |
| --- | --- |
| POW(x,y)，POWER(X,Y) | 返回x的y次方 |
| EXP(X) | 返回e的X次方，其中e是一个常数，2.718281828459045 |
| LN(X)，LOG(X) | 返回以e为底的X的对数，当X <= 0 时，返回的结果为NULL |
| LOG10(X) | 返回以10为底的X的对数，当X <= 0 时，返回的结果为NULL |
| LOG2(X) | 返回以2为底的X的对数，当X <= 0 时，返回NULL |

```sql
mysql> SELECT POW(2,5),POWER(2,4),EXP(2),LN(10),LOG10(10),LOG2(4)
    -> FROM DUAL;
+----------+------------+------------------+-------------------+-----------+---------+
| POW(2,5) | POWER(2,4) | EXP(2)           | LN(10)            | LOG10(10) | LOG2(4) |
+----------+------------+------------------+-------------------+-----------+---------+
|       32 |         16 | 7.38905609893065 | 2.302585092994046 |         1 |       2 |
+----------+------------+------------------+-------------------+-----------+---------+
1 row in set (0.01 sec)
```
### （5) 进制间的转换
| 函数 | 用法 |
| --- | --- |
| BIN(x) | 返回x的二进制编码 |
| HEX(x) | 返回x的十六进制编码 |
| OCT(x) | 返回x的八进制编码 |
| CONV(x,f1,f2) | 返回f1进制数变成f2进制数 |

```sql
mysql> SELECT BIN(10),HEX(10),OCT(10),CONV(10,2,8)
    -> FROM DUAL;
+---------+---------+---------+--------------+
| BIN(10) | HEX(10) | OCT(10) | CONV(10,2,8) |
+---------+---------+---------+--------------+
| 1010    | A       | 12      | 2            |
+---------+---------+---------+--------------+
1 row in set (0.00 sec)
```
## 2. 字符串函数
| 函数 | 用法 |
| --- | --- |
| ASCII(S) | 返回字符串S中的第一个字符的ASCII码值 |
| CHAR_LENGTH(s) | 返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同 |
| LENGTH(s) | 返回字符串s的字节数，和字符集有关 |
| CONCAT(s1,s2,......,sn) | 连接s1,s2,......,sn为一个字符串 |
| CONCAT_WS(x, s1,s2,......,sn) | 同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x |
| INSERT(str, idx, len, replacestr) | 将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr |
| REPLACE(str, a, b) | 用字符串b替换字符串str中所有出现的字符串a |
| UPPER(s) 或 UCASE(s) | 将字符串s的所有字母转成大写字母 |
| LOWER(s) 或LCASE(s) | 将字符串s的所有字母转成小写字母 |
| LEFT(str,n) | 返回字符串str最左边的n个字符 |
| RIGHT(str,n) | 返回字符串str最右边的n个字符 |
| LPAD(str, len, pad) | 用字符串pad对str最左边进行填充，直到str的长度为len个字符 |
| RPAD(str ,len, pad) | 用字符串pad对str最右边进行填充，直到str的长度为len个字符 |
| LTRIM(s) | 去掉字符串s左侧的空格 |
| RTRIM(s) | 去掉字符串s右侧的空格 |
| TRIM(s) | 去掉字符串s开始与结尾的空格 |
| TRIM(s1 FROM s) | 去掉字符串s开始与结尾的s1 |
| TRIM(LEADING s1 FROM s) | 去掉字符串s开始处的s1 |
| TRIM(TRAILING s1 FROM s) | 去掉字符串s结尾处的s1 |
| REPEAT(str, n) | 返回str重复n次的结果 |
| SPACE(n) | 返回n个空格 |
| STRCMP(s1,s2) | 比较字符串s1,s2的ASCII码值的大小 |
| SUBSTR(s,index,len) | 返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、 MID(s,n,len)相同 |
| LOCATE(substr,str) | 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0 |
| ELT(m,s1,s2,…,sn) | 返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn |
| FIELD(s,s1,s2,…,sn)（下面有详细介绍） | 返回字符串s在字符串列表中第一次出现的位置 |
| FIND_IN_SET(s1,s2) | 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 |
| REVERSE(s) | 返回s反转后的字符串 |
| NULLIF(value1,value2) | 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1 |

- **FIELD(s,s1,s2,…,sn)**

在SQL中，**FIELD** 是一个函数，用于返回某个值在一组值中的位置（索引），位置从1开始计数。如果该值未找到，则返回0。这个函数在MySQL中是可用的。
**语法**
```sql
FIELD(value, val1, val2, val3, ...)
```

- **value**：要查找的值。
- **val1, val2, val3, ...**：一组值，在这些值中查找 **value**。
> 注意：MySQL中，字符串的位置是从1开始的。

```sql
mysql> SELECT FIELD('mm','hello','msm','amma'),FIND_IN_SET('mm','hello,mm,amma')
    -> FROM DUAL;
+----------------------------------+-----------------------------------+
| FIELD('mm','hello','msm','amma') | FIND_IN_SET('mm','hello,mm,amma') |
+----------------------------------+-----------------------------------+
|                                0 |                                 2 |
+----------------------------------+-----------------------------------+
1 row in set (0.01 sec)
```
```sql
mysql> SELECT NULLIF('mysql','mysql'),NULLIF('mysql', '');
+-------------------------+---------------------+
| NULLIF('mysql','mysql') | NULLIF('mysql', '') |
+-------------------------+---------------------+
| NULL                    | mysql               |
+-------------------------+---------------------+
1 row in set (0.00 sec)
```
## 3. 日期和时间函数
### （1) 获取日期、时间
| 函数 | 用法 |
| --- | --- |
| **CURDATE() **，CURRENT_DATE() | 返回当前日期，只包含年、 月、日 |
| **CURTIME()** ， CURRENT_TIME() | 返回当前时间，只包含时、 分、秒 |
| **NOW()** / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP() | 返回当前系统日期和时间 |
| UTC_DATE() | 返回UTC（世界标准时间） 日期 |
| UTC_TIME() | 返回UTC（世界标准时间） 时间 |

```sql
mysql> SELECT
    -> CURDATE(),CURTIME(),NOW(),SYSDATE()+0,UTC_DATE(),UTC_DATE()+0,UTC_TIME(),UTC_TIME()+0
    -> FROM DUAL;
+------------+-----------+---------------------+----------------+------------+--------------+------------+--------------+
| CURDATE()  | CURTIME() | NOW()               | SYSDATE()+0    | UTC_DATE() | UTC_DATE()+0 | UTC_TIME() | UTC_TIME()+0 |
+------------+-----------+---------------------+----------------+------------+--------------+------------+--------------+
| 2024-06-03 | 21:14:53  | 2024-06-03 21:14:53 | 20240603211453 | 2024-06-03 |     20240603 | 13:14:53   |       131453 |
+------------+-----------+---------------------+----------------+------------+--------------+------------+--------------+
1 row in set (0.01 sec)
```
### （2) 日期与时间戳的转换
| 函数 | 用法 |
| --- | --- |
| UNIX_TIMESTAMP() | 以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - >1634348884 |
| UNIX_TIMESTAMP(date) | 将时间date以UNIX时间戳的形式返回。 |
| FROM_UNIXTIME(timestamp) | 将UNIX时间戳的时间转换为普通格式的时间 |

```sql
mysql> SELECT UNIX_TIMESTAMP(now());
+-----------------------+
| UNIX_TIMESTAMP(now()) |
+-----------------------+
|            1717420588 |
+-----------------------+
1 row in set (0.01 sec)
```
```sql
mysql> SELECT UNIX_TIMESTAMP(CURDATE());
+---------------------------+
| UNIX_TIMESTAMP(CURDATE()) |
+---------------------------+
|                1717344000 |
+---------------------------+
1 row in set (0.00 sec)

mysql> SELECT UNIX_TIMESTAMP(CURTIME());
+---------------------------+
| UNIX_TIMESTAMP(CURTIME()) |
+---------------------------+
|                1717420660 |
+---------------------------+
1 row in set (0.00 sec)
mysql> SELECT UNIX_TIMESTAMP('2011-11-11 11:11:11')
    -> ;
+---------------------------------------+
| UNIX_TIMESTAMP('2011-11-11 11:11:11') |
+---------------------------------------+
|                            1320981071 |
+---------------------------------------+
1 row in set (0.00 sec)
mysql> SELECT FROM_UNIXTIME(1576380910);
+---------------------------+
| FROM_UNIXTIME(1576380910) |
+---------------------------+
| 2019-12-15 11:35:10       |
+---------------------------+
1 row in set (0.01 sec)
```
### （3) 获取月份、星期、星期数、天数等函数
| 函数 | 用法 |
| --- | --- |
| YEAR(date) / MONTH(date) / DAY(date) | 返回具体的日期值 |
| HOUR(time) / MINUTE(time) / SECOND(time) | 返回具体的时间值 |
| FROM_UNIXTIME(timestamp) | 将UNIX时间戳的时间转换为普通格式的时间 |
| MONTHNAME(date) | 返回月份：January，... |
| DAYNAME(date) | 返回星期几：MONDAY，TUESDAY.....SUNDAY |
| WEEKDAY(date) | 返回周几，注意，周1是0，周2是1，。。。周日是6 |
| QUARTER(date) | 返回日期对应的季度，范围为1～4 |
| WEEK(date) ， WEEKOFYEAR(date) | 返回一年中的第几周 |
| DAYOFYEAR(date) | 返回日期是一年中的第几天 |
| DAYOFMONTH(date) | 返回日期位于所在月份的第几天 |
| DAYOFWEEK(date) | 返回周几，注意：周日是1，周一是2，。。。周六是 7 |

```sql
mysql> SELECT YEAR(CURDATE()),MONTH(CURDATE()),DAY(CURDATE()),
    -> HOUR(CURTIME()),MINUTE(NOW()),SECOND(SYSDATE())
    -> FROM DUAL;
+-----------------+------------------+----------------+-----------------+---------------+-------------------+
| YEAR(CURDATE()) | MONTH(CURDATE()) | DAY(CURDATE()) | HOUR(CURTIME()) | MINUTE(NOW()) | SECOND(SYSDATE()) |
+-----------------+------------------+----------------+-----------------+---------------+-------------------+
|            2024 |                6 |              3 |              21 |            20 |                40 |
+-----------------+------------------+----------------+-----------------+---------------+-------------------+
1 row in set (0.01 sec)
```
```sql
mysql> SELECT MONTHNAME('2021-10-26'),DAYNAME('2021-10-26'),WEEKDAY('2021-10-26'),
    -> QUARTER(CURDATE()),WEEK(CURDATE()),DAYOFYEAR(NOW()),
    -> DAYOFMONTH(NOW()),DAYOFWEEK(NOW())
    -> FROM DUAL;
+-------------------------+-----------------------+-----------------------+--------------------+-----------------+------------------+-------------------+------------------+
| MONTHNAME('2021-10-26') | DAYNAME('2021-10-26') | WEEKDAY('2021-10-26') | QUARTER(CURDATE()) | WEEK(CURDATE()) | DAYOFYEAR(NOW()) | DAYOFMONTH(NOW()) | DAYOFWEEK(NOW()) |
+-------------------------+-----------------------+-----------------------+--------------------+-----------------+------------------+-------------------+------------------+
| October                 | Tuesday               |                     1 |                  2 |              22 |              155 |                 3 |                2 |
+-------------------------+-----------------------+-----------------------+--------------------+-----------------+------------------+-------------------+------------------+
1 row in set (0.00 sec)
```
### （4) 日期的操作函数
| 函数 | 用法 |
| --- | --- |
| EXTRACT(type FROM date) | 返回指定日期中特定的部分，type指定返回的值 |

EXTRACT(type FROM date)函数中type的取值与含义：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717421018881-e16f1764-6dbe-43fd-a791-347fb40e336c.png#averageHue=%23efefef&clientId=uc8550b36-0b85-4&from=paste&height=597&id=u44f5f220&originHeight=746&originWidth=938&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=203912&status=done&style=none&taskId=u7c44150f-d3ac-4a18-b99e-246a980ff37&title=&width=750.4)
![](MySQL%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20220601162705975.png#id=G0UhU&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
```sql
mysql> SELECT EXTRACT(MINUTE FROM NOW()),EXTRACT( WEEK FROM NOW()),
    -> EXTRACT( QUARTER FROM NOW()),EXTRACT( MINUTE_SECOND FROM NOW())
    -> FROM DUAL;
+----------------------------+---------------------------+------------------------------+------------------------------------+
| EXTRACT(MINUTE FROM NOW()) | EXTRACT( WEEK FROM NOW()) | EXTRACT( QUARTER FROM NOW()) | EXTRACT( MINUTE_SECOND FROM NOW()) |
+----------------------------+---------------------------+------------------------------+------------------------------------+
|                         25 |                        22 |                            2 |
2513 |
+----------------------------+---------------------------+------------------------------+------------------------------------+
1 row in set (0.00 sec)
```
### （5) 时间和秒钟转换的函数
| 函数 | 用法 |
| --- | --- |
| TIME_TO_SEC(time) | 将 time 转化为秒并返回结果值。转化的公式为： 小时_3600+分钟 _60+秒 |
| SEC_TO_TIME(seconds) | 将 seconds 描述转化为包含小时、分钟和秒的时间 |

```sql
mysql> SELECT TIME_TO_SEC(NOW());
+--------------------+
| TIME_TO_SEC(NOW()) |
+--------------------+
|              77230 |
+--------------------+
1 row in set (0.01 sec)
mysql> SELECT SEC_TO_TIME(78774);
+--------------------+
| SEC_TO_TIME(78774) |
+--------------------+
| 21:52:54           |
+--------------------+
1 row in set (0.01 sec)
```
### （6）计算日期和时间的函数
**第一组：**

| 函数 | 用法 |
| --- | --- |
| DATE_ADD(datetime, INTERVAL expr type)， ADDDATE(date,INTERVAL expr type) | 返回与给定日期时间相差INTERVAL时间段的日期时间 |
| DATE_SUB(date,INTERVAL expr type)， SUBDATE(date,INTERVAL expr type) | 返回与date相差INTERVAL时间间隔的日期 |

上述函数中type的取值：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717421296750-729b2319-4800-408f-a64f-6354dd6615f0.png#averageHue=%23f1f1f1&clientId=uc8550b36-0b85-4&from=paste&height=398&id=u2457240f&originHeight=498&originWidth=934&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=83813&status=done&style=none&taskId=ue93d42db-c7ac-4455-b4e7-754209e2723&title=&width=747.2)
```sql
mysql> SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,DATE_ADD('2021-10-21 23:32:12',INTERVAL
    -> 1 SECOND) AS col2,
    -> ADDDATE('2021-10-21 23:32:12',INTERVAL 1 SECOND) AS col3,
    -> DATE_ADD('2021-10-21 23:32:12',INTERVAL '1_1' MINUTE_SECOND) AS col4,
    -> DATE_ADD(NOW(), INTERVAL -1 YEAR) AS col5, #可以是负数
    -> DATE_ADD(NOW(), INTERVAL '1_1' YEAR_MONTH) AS col6 #需要单引号
    -> FROM DUAL;
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| col1                | col2                | col3                | col4                | col5                | col6                |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
| 2024-06-04 21:28:54 | 2021-10-21 23:32:13 | 2021-10-21 23:32:13 | 2021-10-21 23:33:13 | 2023-06-03 21:28:54 | 2025-07-03 21:28:54 |
+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+
1 row in set (0.01 sec)

mysql> SELECT DATE_SUB('2021-01-21',INTERVAL 31 DAY) AS col1,
    -> SUBDATE('2021-01-21',INTERVAL 31 DAY) AS col2,
    -> DATE_SUB('2021-01-21 02:01:01',INTERVAL '1 1' DAY_HOUR) AS col3
    -> FROM DUAL;
+------------+------------+---------------------+
| col1       | col2       | col3                |
+------------+------------+---------------------+
| 2020-12-21 | 2020-12-21 | 2021-01-20 01:01:01 |
+------------+------------+---------------------+
1 row in set (0.00 sec)
```
![](MySQL%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20220601165055639.png#id=awKsT&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)**第二组：**

| 函数 | 用法 |
| --- | --- |
| ADDTIME(time1,time2) | 返回time1加上time2的时间。当time2为一个数字时，代表的是 秒 ，可以为负数 |
| SUBTIME(time1,time2) | 返回time1减去time2后的时间。当time2为一个数字时，代表的 是 秒 ，可以为负数 |
| DATEDIFF(date1,date2) | 返回date1 - date2的日期间隔天数 |
| TIMEDIFF(time1, time2) | 返回time1 - time2的时间间隔 |
| FROM_DAYS(N) | 返回从0000年1月1日起，N天以后的日期 |
| TO_DAYS(date) | 返回日期date距离0000年1月1日的天数 |
| LAST_DAY(date) | 返回date所在月份的最后一天的日期 |
| MAKEDATE(year,n) | 针对给定年份与所在年份中的天数返回一个日期 |
| MAKETIME(hour,minute,second) | 将给定的小时、分钟和秒组合成时间并返回 |
| PERIOD_ADD(time,n) | 返回time加上n后的时间 |

```sql
mysql> SELECT
    -> ADDTIME(NOW(),20),SUBTIME(NOW(),30),SUBTIME(NOW(),'1:1:3'),DATEDIFF(NOW(),'2021-10-
    '> 01'),
    -> TIMEDIFF(NOW(),'2021-10-25 22:10:10'),FROM_DAYS(366),TO_DAYS('0000-12-25'),
    -> LAST_DAY(NOW()),MAKEDATE(YEAR(NOW()),12),MAKETIME(10,21,23),PERIOD_ADD(20200101010101,
    -> 10)
    -> FROM DUAL;
+---------------------+---------------------+------------------------+-------------------------------+---------------------------------------+----------------+-----------------------+-----------------+--------------------------+--------------------+--------------------------------+
| ADDTIME(NOW(),20)   | SUBTIME(NOW(),30)   | SUBTIME(NOW(),'1:1:3') | DATEDIFF(NOW(),'2021-10-
01') | TIMEDIFF(NOW(),'2021-10-25 22:10:10') | FROM_DAYS(366) | TO_DAYS('0000-12-25') | LAST_DAY(NOW()) | MAKEDATE(YEAR(NOW()),12) | MAKETIME(10,21,23) | PERIOD_ADD(20200101010101,
10) |
+---------------------+---------------------+------------------------+-------------------------------+---------------------------------------+----------------+-----------------------+-----------------+--------------------------+--------------------+--------------------------------+
| 2024-06-03 21:30:03 | 2024-06-03 21:29:13 | 2024-06-03 20:28:40    |                          NULL | 838:59:59                             | 0001-01-01     |                   359 | 2024-06-30      | 2024-01-12               | 10:21:23           |                 20200101010111 |
+---------------------+---------------------+------------------------+-------------------------------+---------------------------------------+----------------+-----------------------+-----------------+--------------------------+--------------------+--------------------------------+
1 row in set, 2 warnings (0.01 sec)

mysql> SELECT ADDTIME(NOW(), 50);
+---------------------+
| ADDTIME(NOW(), 50)  |
+---------------------+
| 2024-06-03 21:30:41 |
+---------------------+
1 row in set (0.00 sec)
```
```sql
mysql> SELECT SUBTIME(NOW(), '1:1:1');
+-------------------------+
| SUBTIME(NOW(), '1:1:1') |
+-------------------------+
| 2024-06-03 20:30:09     |
+-------------------------+
1 row in set (0.00 sec)
mysql> SELECT SUBTIME(NOW(), '-1:-1:-1');
+----------------------------+
| SUBTIME(NOW(), '-1:-1:-1') |
+----------------------------+
| 2024-06-03 21:31:39        |
+----------------------------+
1 row in set, 1 warning (0.00 sec)

mysql>  SELECT FROM_DAYS(366);
+----------------+
| FROM_DAYS(366) |
+----------------+
| 0001-01-01     |
+----------------+
1 row in set (0.00 sec)

mysql> SELECT MAKEDATE(2020,1);
+------------------+
| MAKEDATE(2020,1) |
+------------------+
| 2020-01-01       |
+------------------+
1 row in set (0.00 sec)

mysql> SELECT MAKEDATE(2020,32);
+-------------------+
| MAKEDATE(2020,32) |
+-------------------+
| 2020-02-01        |
+-------------------+
1 row in set (0.00 sec)

mysql> SELECT MAKETIME(1,1,1);
+-----------------+
| MAKETIME(1,1,1) |
+-----------------+
| 01:01:01        |
+-----------------+
1 row in set (0.00 sec)
mysql> SELECT PERIOD_ADD(20200101010101,1);
+------------------------------+
| PERIOD_ADD(20200101010101,1) |
+------------------------------+
|               20200101010102 |
+------------------------------+
1 row in set (0.00 sec)

mysql> SELECT TO_DAYS(NOW());
+----------------+
| TO_DAYS(NOW()) |
+----------------+
|         739405 |
+----------------+
1 row in set (0.00 sec)
```
### （7)  日期的格式化与解析
| 函数 | 用法 |
| --- | --- |
| DATE_FORMAT(date,fmt) | 按照字符串fmt格式化日期date值 |
| TIME_FORMAT(time,fmt) | 按照字符串fmt格式化时间time值 |
| GET_FORMAT(date_type,format_type) | 返回日期字符串的显示格式 |
| STR_TO_DATE(str, fmt) | 按照字符串fmt对str进行解析，解析为一个日期 |

上述 非GET_FORMAT 函数中fmt参数常用的格式符：

| 格式符 | 说明 | 格式符 | 说明 |
| --- | --- | --- | --- |
| %Y | 4位数字表示年份 | %y | 表示两位数字表示年份 |
| %M | 月名表示月份（January,....） | %m | 两位数字表示月份 （01,02,03。。。） |
| %b | 缩写的月名（Jan.，Feb.，....） | %c | 数字表示月份（1,2,3,...） |
| %D | 英文后缀表示月中的天数 （1st,2nd,3rd,...） | %d | 两位数字表示月中的天数(01,02...) |
| %e | 数字形式表示月中的天数 （1,2,3,4,5.....） |  |  |
| %H | 两位数字表示小数，24小时制 （01,02..） | %h 和%I | 两位数字表示小时，12小时制 （01,02..） |
| %k | 数字形式的小时，24小时制(1,2,3) | %l | 数字形式表示小时，12小时制 （1,2,3,4....） |
| %i | 两位数字表示分钟（00,01,02） | %S 和%s | 两位数字表示秒(00,01,02...) |
| %W | 一周中的星期名称（Sunday...） | %a | 一周中的星期缩写（Sun.， Mon.,Tues.，..） |
| %w | 以数字表示周中的天数 (0=Sunday,1=Monday....) |  |  |
| %j | 以3位数字表示年中的天数(001,002...) | %U | 以数字表示年中的第几周， （1,2,3。。）其中Sunday为周中第一 天 |
| %u | 以数字表示年中的第几周， （1,2,3。。）其中Monday为周中第一 天 |  |  |
| %T | 24小时制 | %r | 12小时制 |
| %p | AM或PM | %% | 表示% |

GET_FORMAT函数中date_type和format_type参数取值如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717421736913-e4db3378-436f-4e9e-a29c-90060fa3882f.png#averageHue=%23f0f0f0&clientId=uc8550b36-0b85-4&from=paste&height=408&id=CsnMs&originHeight=510&originWidth=941&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=130092&status=done&style=none&taskId=u4ee1c448-11cb-42e6-a7b2-1f1bdb6133e&title=&width=752.8)
```sql
mysql> SELECT DATE_FORMAT(NOW(), '%H:%i:%s');
+--------------------------------+
| DATE_FORMAT(NOW(), '%H:%i:%s') |
+--------------------------------+
| 21:39:55                       |
+--------------------------------+
1 row in set (0.00 sec)

mysql> SELECT STR_TO_DATE('09/01/2009','%m/%d/%Y')
    -> FROM DUAL;
+--------------------------------------+
| STR_TO_DATE('09/01/2009','%m/%d/%Y') |
+--------------------------------------+
| 2009-09-01                           |
+--------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT STR_TO_DATE('20140422154706','%Y%m%d%H%i%s')
    -> FROM DUAL;
+----------------------------------------------+
| STR_TO_DATE('20140422154706','%Y%m%d%H%i%s') |
+----------------------------------------------+
| 2014-04-22 15:47:06                          |
+----------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT STR_TO_DATE('2014-04-22 15:47:06','%Y-%m-%d %H:%i:%s')
    -> FROM DUAL;
+--------------------------------------------------------+
| STR_TO_DATE('2014-04-22 15:47:06','%Y-%m-%d %H:%i:%s') |
+--------------------------------------------------------+
| 2014-04-22 15:47:06                                    |
+--------------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT GET_FORMAT(DATE, 'USA');
+-------------------------+
| GET_FORMAT(DATE, 'USA') |
+-------------------------+
| %m.%d.%Y                |
+-------------------------+
1 row in set (0.00 sec)

mysql> SELECT STR_TO_DATE('2020-01-01 00:00:00','%Y-%m-%d');
+-----------------------------------------------+
| STR_TO_DATE('2020-01-01 00:00:00','%Y-%m-%d') |
+-----------------------------------------------+
| 2020-01-01                                    |
+-----------------------------------------------+
1 row in set, 1 warning (0.00 sec)

```
## 4. 流程控制函数
流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。 MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。

| 函数 | 用法 |
| --- | --- |
| IF(value,value1,value2) | 如果value的值为TRUE，返回value1， 否则返回value2 |
| IFNULL(value1, value2) | 如果value1不为NULL，返回value1，否则返回value2 |
| CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 .... [ELSE resultn] END | 相当于Java的if...else if...else... |
| CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END | 相当于Java的switch...case... |

```sql
mysql> SELECT IF(1 > 0,'正确','错误');
+-------------------------+
| IF(1 > 0,'正确','错误') |
+-------------------------+
| 正确                    |
+-------------------------+
1 row in set (0.00 sec)

mysql> SELECT IFNULL(null,'Hello Word');
+---------------------------+
| IFNULL(null,'Hello Word') |
+---------------------------+
| Hello Word                |
+---------------------------+
1 row in set (0.00 sec)

mysql> SELECT CASE
    ->  WHEN 1 > 0
    ->  THEN '1 > 0'
    ->  WHEN 2 > 0
    ->  THEN '2 > 0'
    ->  ELSE '3 > 0'
    ->  END;
+-----------------------------------------------------------------------------+
| CASE
        WHEN 1 > 0
        THEN '1 > 0'
        WHEN 2 > 0
        THEN '2 > 0'
        ELSE '3 > 0'
 END |
+-----------------------------------------------------------------------------+
| 1 > 0                                                                       |
+-----------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT CASE 1
    ->     WHEN 1 THEN '我是1'
    ->     WHEN 2 THEN '我是2'
    ->     ELSE '你是谁'
    -> END;
+------------------------------------------------------------------------------+
| CASE 1
    WHEN 1 THEN '我是1'
    WHEN 2 THEN '我是2'
    ELSE '你是谁'
END |
+------------------------------------------------------------------------------+
| 我是1                                                                        |
+------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT employee_id, salary,
    ->     CASE
    ->         WHEN salary >= 15000 THEN '高薪'
    ->         WHEN salary >= 10000 THEN '潜力股'
    ->         WHEN salary >= 8000 THEN '屌丝'
    ->         ELSE '草根'
    ->     END  "描述"
    -> FROM employees;
+-------------+----------+--------+
| employee_id | salary   | 描述   |
+-------------+----------+--------+
|         100 | 24000.00 | 高薪   |
|         101 | 17000.00 | 高薪   |
|         102 | 17000.00 | 高薪   |
|         103 |  9000.00 | 屌丝   |
|         104 |  6000.00 | 草根   |
|         105 |  4800.00 | 草根   |
|         106 |  4800.00 | 草根   |
…………

SELECT oid, `status`,
    CASE `status`
        WHEN 1 THEN '未付款'
        WHEN 2 THEN '已付款'
        WHEN 3 THEN '已发货'
        WHEN 4 THEN '确认收货'
        ELSE '无效订单'
    END 
FROM t_order;

mysql> SELECT CASE WHEN 1 > 0 THEN 'yes' WHEN 1 <= 0 THEN 'no' ELSE 'unknown' END;
+---------------------------------------------------------------------+
| CASE WHEN 1 > 0 THEN 'yes' WHEN 1 <= 0 THEN 'no' ELSE 'unknown' END |
+---------------------------------------------------------------------+
| yes                                                                 |
+---------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT CASE WHEN 1 < 0 THEN 'yes' WHEN 1 = 0 THEN 'no' ELSE 'unknown' END;
+--------------------------------------------------------------------+
| CASE WHEN 1 < 0 THEN 'yes' WHEN 1 = 0 THEN 'no' ELSE 'unknown' END |
+--------------------------------------------------------------------+
| unknown                                                            |
+--------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;
+------------------------------------------------+
| CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |
+------------------------------------------------+
|                                              1 |
+------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;
+-------------------------------------------------+
| CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |
+-------------------------------------------------+
|                                              -1 |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT last_name, job_id, salary,
    ->     CASE job_id
    ->         WHEN 'IT_PROG' THEN 1.10 * salary
    ->         WHEN 'ST_CLERK' THEN 1.15 * salary
    ->         WHEN 'SA_REP' THEN 1.20 * salary
    ->         ELSE salary
    ->     END AS "REVISED_SALARY"
    -> FROM employees;
+-------------+------------+----------+----------------+
| last_name   | job_id     | salary   | REVISED_SALARY |
+-------------+------------+----------+----------------+
| King        | AD_PRES    | 24000.00 |       24000.00 |
| Kochhar     | AD_VP      | 17000.00 |       17000.00 |
| De Haan     | AD_VP      | 17000.00 |       17000.00 |
| Hunold      | IT_PROG    |  9000.00 |        9900.00 |
| Ernst       | IT_PROG    |  6000.00 |        6600.00 |
| Austin      | IT_PROG    |  4800.00 |        5280.00 |
| Pataballa   | IT_PROG    |  4800.00 |        5280.00 |
| Lorentz     | IT_PROG    |  4200.00 |        4620.00 |
| Greenberg   | FI_MGR     | 12000.00 |       12000.00 |
| Faviet      | FI_ACCOUNT |  9000.00 |        9000.00 |
……
```
## 5. 加密与解密函数
加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。

| 函数 | 用法 |
| --- | --- |
| PASSWORD(str)（在mysql较新 的版本中已被弃用） | 返回字符串str的加密版本，41位长的字符串。加密结果不可逆 ，常用于用户的密码加密 |
| MD5(str) | 返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL |
| SHA(str) | 从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。 SHA加密算法比MD5更加安全 。 |
| ENCODE(value,password_seed)
（Mysql较新的版本不可用） | 返回使用password_seed作为加密密码加密value |
| DECODE(value,password_seed) | 返回使用password_seed作为加密密码解密value |

可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。
```sql
mysql> SELECT md5('123');
+----------------------------------+
| md5('123')                       |
+----------------------------------+
| 202cb962ac59075b964b07152d234b70 |
+----------------------------------+
1 row in set (0.01 sec)

mysql> SELECT SHA('Tom123');
+------------------------------------------+
| SHA('Tom123')                            |
+------------------------------------------+
| c7c506980abc31cc390a2438c90861d0f1216d50 |
+------------------------------------------+
1 row in set (0.00 sec)
```
## 6. MySQL信息函数
MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地 对数据库进行维护工作。

| 函数 | 用法 |
| --- | --- |
| VERSION() | 返回当前MySQL的版本号 |
| CONNECTION_ID() | 返回当前MySQL服务器的连接数 |
| DATABASE()，SCHEMA() | 返回MySQL命令行当前所在的数据库 |
| USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER() | 返回当前连接MySQL的用户名，返回结果格式为 “主机名@用户名” |
| CHARSET(value) | 返回字符串value自变量的字符集 |
| COLLATION(value) | 返回字符串value的比较规则 |

```sql
mysql> SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| atguigudb  |
+------------+
1 row in set (0.00 sec)

mysql> SELECT USER(), CURRENT_USER(), SYSTEM_USER(),SESSION_USER();
+----------------+----------------+----------------+----------------+
| USER()         | CURRENT_USER() | SYSTEM_USER()  | SESSION_USER() |
+----------------+----------------+----------------+----------------+
| root@localhost | root@localhost | root@localhost | root@localhost |
+----------------+----------------+----------------+----------------+
1 row in set (0.01 sec)

mysql> SELECT CHARSET('ABC');
+----------------+
| CHARSET('ABC') |
+----------------+
| gbk            |
+----------------+
1 row in set (0.00 sec)

mysql> SELECT COLLATION('ABC');
+------------------+
| COLLATION('ABC') |
+------------------+
| gbk_chinese_ci   |
+------------------+
1 row in set (0.00 sec)
```
MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视 的。

| 函数 | 用法 |
| --- | --- |
| FORMAT(value,n) | 返回对数字value进行格式化后的结果数据。n表示 四舍五入 后保留 到小数点后n位 |
| CONV(value,from,to) | 将value的值进行不同进制之间的转换 |
| INET_ATON(ipvalue) | 将以点分隔的IP地址转化为一个数字 |
| INET_NTOA(value) | 将数字形式的IP地址转化为以点分隔的IP地址 |
| BENCHMARK(n,expr) | 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费 的时间 |
| CONVERT(value USING char_code) | 将value所使用的字符编码修改为char_code |

```sql
# 如果n的值小于或者等于0，则只保留整数部分
mysql> SELECT FORMAT(123.123, 2), FORMAT(123.523, 0), FORMAT(123.123, -2);
+--------------------+--------------------+---------------------+
| FORMAT(123.123, 2) | FORMAT(123.523, 0) | FORMAT(123.123, -2) |
+--------------------+--------------------+---------------------+
| 123.12       | 124        | 123         |
+--------------------+--------------------+---------------------+
1 row in set (0.00 sec)

mysql> SELECT CONV(16, 10, 2), CONV(8888,10,16), CONV(NULL, 10, 2);
+-----------------+------------------+-------------------+
| CONV(16, 10, 2) | CONV(8888,10,16) | CONV(NULL, 10, 2) |
+-----------------+------------------+-------------------+
| 10000           | 22B8             | NULL              |
+-----------------+------------------+-------------------+
1 row in set (0.00 sec)

mysql> SELECT INET_ATON('192.168.1.100');
+----------------------------+
| INET_ATON('192.168.1.100') |
+----------------------------+
|                 3232235876 |
+----------------------------+
1 row in set (0.01 sec)
# 以“192.168.1.100”为例，计算方式为192乘以256的3次方，加上168乘以256的2次方，加上1乘以256，再加上
100。

mysql> SELECT INET_NTOA(3232235876);
+-----------------------+
| INET_NTOA(3232235876) |
+-----------------------+
| 192.168.1.100         |
+-----------------------+
1 row in set (0.00 sec)

mysql> SELECT BENCHMARK(1, MD5('mysql'));
+----------------------------+
| BENCHMARK(1, MD5('mysql')) |
+----------------------------+
|                          0 |
+----------------------------+
1 row in set (0.00 sec)

mysql> SELECT BENCHMARK(1000000, MD5('mysql'));
+----------------------------------+
| BENCHMARK(1000000, MD5('mysql')) |
+----------------------------------+
|                                0 |
+----------------------------------+
1 row in set (0.88 sec)

mysql> SELECT CHARSET('mysql'), CHARSET(CONVERT('mysql' USING 'utf8'));
+------------------+----------------------------------------+
| CHARSET('mysql') | CHARSET(CONVERT('mysql' USING 'utf8')) |
+------------------+----------------------------------------+
| gbk              | utf8mb3                                |
+------------------+----------------------------------------+
1 row in set, 1 warning (0.01 sec)
```
# 第六章 聚合函数
## 1. 聚合函数介绍

- **什么是聚合函数**

聚合函数作用于一组数据，并对一组数据返回一个值。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717489160169-26374878-b050-4dbd-b450-5eb45a54887f.png#averageHue=%23f5eee9&clientId=u49230479-29cc-4&from=paste&height=346&id=u938d5b44&originHeight=551&originWidth=905&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=82227&status=done&style=none&taskId=udf711fb8-9416-485c-aa7a-de7118bed9f&title=&width=569)

- **聚合函数类型 **
   - **AVG()**
   - **SUM()**
   - **MAX()**
   - **MIN()**
   - **COUNT()**
### （1）AVG和SUM函数
可以对**数值型数据**使用AVG 和 SUM 函数。
```sql
mysql> SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)
    -> FROM employees
    -> WHERE job_id LIKE '%REP%';
+-------------+-------------+-------------+-------------+
| AVG(salary) | MAX(salary) | MIN(salary) | SUM(salary) |
+-------------+-------------+-------------+-------------+
| 8272.727273 |    11500.00 |     6000.00 |   273000.00 |
+-------------+-------------+-------------+-------------+
1 row in set (0.01 sec)
```
### （2）MIN和MAX函数
可以对**任意数据类型**的数据使用 MIN 和 MAX 函数。
```sql
mysql> SELECT MIN(hire_date), MAX(hire_date)
    -> FROM employees;
+----------------+----------------+
| MIN(hire_date) | MAX(hire_date) |
+----------------+----------------+
| 1987-06-17     | 2000-04-21     |
+----------------+----------------+
1 row in set (0.01 sec)
```
### （3）COUNT函数
COUNT(*)返回表中记录总数，适用于**任意数据类型**。
```sql
mysql> SELECT COUNT(*)
    -> FROM employees
    -> WHERE department_id = 50;
+----------+
| COUNT(*) |
+----------+
|       45 |
+----------+
1 row in set (0.00 sec)
```
COUNT(expr) 返回**expr不为空**的记录总数。
```sql
mysql> SELECT COUNT(commission_pct)
    -> FROM employees
    -> WHERE department_id = 50;
+-----------------------+
| COUNT(commission_pct) |
+-----------------------+
|                     0 |
+-----------------------+
1 row in set (0.01 sec)
```

- **问题：用count(*)，count(1)，count(列名)谁好呢?**

其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好 于具体的count(列名)。

- **问题：能不能使用count(列名)替换count(*)?**

不要使用 count(列名)来替代 count(*)_ ,count(*)_ 是 SQL92 定义的标准统计行数的语法，跟数 据库无关，跟 NULL 和非 NULL 无关。 
说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。
## 2. GROUP BY
### （1) 基本使用
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717489862651-f5f47e5a-5ca2-44e8-97ae-b8bb82039839.png#averageHue=%23f4eae7&clientId=u49230479-29cc-4&from=paste&height=421&id=u8f9ebbf5&originHeight=572&originWidth=911&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=115417&status=done&style=none&taskId=u90d78236-ff12-4c7a-8dea-b50fb88262e&title=&width=671)
**可以使用GROUP BY子句将表中的数据分成若干组**
**语法结构**
```sql
SELECT column1, column2, ..., AGGREGATE_FUNCTION(column_name)
FROM table_name
WHERE condition
GROUP BY column1, column2, ...;
```
详细解释：
1. SELECT column1, column2, ..., AGGREGATE_FUNCTION(column_name)

- SELECT 语句用于指定查询结果中应该包含的列。以下是它的组成部分：
   - column1, column2, ...: 这些是普通的列名，表示你希望在结果集中包含的列。可以包含一个或多个列。
   - AGGREGATE_FUNCTION(column_name): 这是一个聚合函数，它在分组的基础上计算某些统计值。

2. FROM table_name
FROM 子句用于指定你要查询的数据表的名称。table_name 是表的名称。
3. WHERE condition
WHERE 子句用于指定筛选条件，只返回满足条件的行。condition 可以是任何有效的条件表达式，例
4. GROUP BY column1, column2, ...
GROUP BY 子句用于将结果集按照一个或多个列进行分组。以下是它的组成部分：

- column1, column2, ...: 这些是用于分组的列名。结果集将按照这些列的值进行分组。
- 每个分组中的行将被视为一个整体，聚合函数将在每个分组内进行计算。

**注意：WHERE一定放在FROM后面**
**在使用 GROUP BY 子句进行分组查询时，SELECT 列表中的所有列，如果没有参与聚合函数的计算，必须在 GROUP BY 子句中出现。**
原因：
SQL 标准要求，如果在一个查询中使用了 GROUP BY 子句，那么 SELECT 列表中的所有列必须是：

      - 被包含在 GROUP BY 子句中，或者
      - 被聚合函数包裹。

这样做的目的是为了确保结果集是明确且一致的。因为 GROUP BY 是用来分组的，未被聚合函数包裹的列必须是某个特定分组的标识，否则 SQL 引擎不知道如何处理这些未分组的列。
```sql
mysql> SELECT department_id, AVG(salary)
    -> FROM employees
    -> GROUP BY department_id;
+---------------+--------------+
| department_id | AVG(salary)  |
+---------------+--------------+
|          NULL |  7000.000000 |
|            10 |  4400.000000 |
|            20 |  9500.000000 |
|            30 |  4150.000000 |
|            40 |  6500.000000 |
|            50 |  3475.555556 |
|            60 |  5760.000000 |
|            70 | 10000.000000 |
|            80 |  8955.882353 |
|            90 | 19333.333333 |
|           100 |  8600.000000 |
|           110 | 10150.000000 |
+---------------+--------------+
12 rows in set (0.01 sec)
```
包含在 GROUP BY 子句中的列不必包含在SELECT 列表中
```sql
mysql> SELECT AVG(salary)
    -> FROM employees
    -> GROUP BY department_id;
+--------------+
| AVG(salary)  |
+--------------+
|  7000.000000 |
|  4400.000000 |
|  9500.000000 |
|  4150.000000 |
|  6500.000000 |
|  3475.555556 |
|  5760.000000 |
| 10000.000000 |
|  8955.882353 |
| 19333.333333 |
|  8600.000000 |
| 10150.000000 |
+--------------+
12 rows in set (0.00 sec)
```
> 结论1：SELECT中出现的非组函数的字段必须声明在GROUP BY中。
> 反之，GROUP BY中声明的字段可以不出现在SELECT中。
> 结论2：GROUP BY声明在FROM后面、WHERE后面、ORDER BY前面、LIMIT前面。

### （2) 使用多个列分组
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717491208323-feb7c04a-fc6e-46bf-8eda-b2c6dc1871a7.png#averageHue=%23f1e8e3&clientId=u49230479-29cc-4&from=paste&height=388&id=ubf753ee8&originHeight=561&originWidth=916&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=157045&status=done&style=none&taskId=u167751d3-2227-42b9-934d-c6980c069e0&title=&width=633)
```sql
mysql> SELECT department_id dept_id, job_id, SUM(salary)
    -> FROM employees
    -> GROUP BY department_id, job_id;
+---------+------------+-------------+
| dept_id | job_id     | SUM(salary) |
+---------+------------+-------------+
|      90 | AD_PRES    |    24000.00 |
|      90 | AD_VP      |    34000.00 |
|      60 | IT_PROG    |    28800.00 |
|     100 | FI_MGR     |    12000.00 |
|     100 | FI_ACCOUNT |    39600.00 |
|      30 | PU_MAN     |    11000.00 |
|      30 | PU_CLERK   |    13900.00 |
|      50 | ST_MAN     |    36400.00 |
……
```
### （3）WITH ROLLUP
WITH ROLLUP 是 SQL 中的一个扩展功能，用于在分组聚合查询中提供附加的汇总行。它允许我们在使用 GROUP BY 进行分组聚合计算时，自动生成小计和总计。WITH ROLLUP 可以帮助我们轻松地生成不同层次上的汇总数据，无需额外编写复杂的 SQL 语句。
使用 WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。
```sql
mysql> SELECT department_id,AVG(salary)
    -> FROM employees
    -> WHERE department_id > 80
    -> GROUP BY department_id WITH ROLLUP;
+---------------+--------------+
| department_id | AVG(salary)  |
+---------------+--------------+
|            90 | 19333.333333 |
|           100 |  8600.000000 |
|           110 | 10150.000000 |
|          NULL | 11809.090909 |
+---------------+--------------+
4 rows in set (0.01 sec)
```
> 注意： 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。

## 3. HAVING
### (1) 基本使用
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717491838404-d73291e2-c37e-4d9f-b102-4350d36b5670.png#averageHue=%23f7eeea&clientId=u49230479-29cc-4&from=paste&height=369&id=u06cc30d3&originHeight=544&originWidth=918&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=85052&status=done&style=none&taskId=uefb36c03-c9ad-43d8-abe3-0c4db3d105e&title=&width=622)
HAVING 子句在 SQL 中用于对 GROUP BY 子句生成的结果进行过滤。与 WHERE 子句不同，HAVING 子句是用于过滤聚合结果的。WHERE 子句用于在分组前过滤行，而 HAVING 子句用于在分组后过滤分组。
以下是 HAVING 子句的详细介绍及其用法示例：
**基本语法**
```sql
SELECT column1, column2, AGGREGATE_FUNCTION(column3)
FROM table_name
WHERE condition
GROUP BY column1, column2
HAVING aggregate_condition;
```
**关键点**

1. 使用场景：HAVING 子句通常与聚合函数（如 COUNT, SUM, AVG, MAX, MIN）一起使用，用于过滤分组后的结果。
2. 位置：HAVING 子句必须放在 GROUP BY 子句之后，并且在 ORDER BY 子句之前。
3. 条件：HAVING 子句中的条件可以包含聚合函数，而 WHERE 子句中不能。
```sql
mysql> SELECT department_id, MAX(salary)
    -> FROM employees
    -> GROUP BY department_id
    -> HAVING MAX(salary)>10000 ;
+---------------+-------------+
| department_id | MAX(salary) |
+---------------+-------------+
|            20 |    13000.00 |
|            30 |    11000.00 |
|            80 |    14000.00 |
|            90 |    24000.00 |
|           100 |    12000.00 |
|           110 |    12000.00 |
+---------------+-------------+
6 rows in set (0.00 sec)
```

- **非法使用聚合函数 ： 不能在 WHERE 子句中使用聚合函数。如下：**
```sql
SELECT  department_id, AVG(salary)
FROM   employees
WHERE  AVG(salary) > 8000
GROUP BY department_id;
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717492258342-5fb4e6bc-bfc8-4989-b8ce-d04f73f71909.png#averageHue=%23c7bdbd&clientId=u49230479-29cc-4&from=paste&height=138&id=u6f4f82a8&originHeight=173&originWidth=936&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38638&status=done&style=none&taskId=uae5fd3dc-51fa-4d95-a8fa-1911c008628&title=&width=748.8)
**要求**

- 如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE。否则，报错。
- 当过滤条件中没有聚合函数时，则次过滤条件声明在WHERE中或HAVING中都可以。但是，建议声明在WHERE中的执行效率高。
- HAVING必须声明在GROUP BY 的后面
- 开发中，我们使用HAVING的前提是SQL中使用了GROUP BY。
### （2) WHERE和HAVING的对比
**区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件； HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。**
这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为， 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之 后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成 的。另外，WHERE排除的记录不再包括在分组中。
**区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接 后筛选。**
这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一 个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要 先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用 的资源就比较多，执行效率也较低。
小结如下：

| 关键字 | 用法 | 缺点 |
| --- | --- | --- |
| WHERE | 先筛选数据再关联，执行效率高 | 不能使用分组中的计算函数进行筛选 |
| HAVING | 可以使用分组中的计算函数 | 在最后的结果集中进行筛选，执行效率较低 |

**开发中的选择：**
WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组 统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发 挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很 大的差别。
## 4. SELECT的执行过程
### （1) 查询的结构
```sql
#方式1：
SELECT ...,....,...
FROM ...,...,....
WHERE 多表的连接条件
AND 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...
#方式2：
SELECT ...,....,...
FROM ... JOIN ...
ON 多表的连接条件
JOIN ...
ON ...
WHERE 不包含组函数的过滤条件
AND/OR 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...
#其中：
#（1）from：从哪些表中筛选
#（2）on：关联多表查询时，去除笛卡尔积
#（3）where：从表中筛选的条件
#（4）group by：分组依据
#（5）having：在统计结果中再次筛选
#（6）order by：排序
#（7）limit：分页
```
**需要记住 SELECT 查询时的两个顺序：**
**1. 关键字的顺序是不能颠倒的：**
```sql
SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...
```
**2. SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：**
```sql
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT -> ORDER BY -> LIMIT
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717492644217-444a4f1d-9c15-4824-a8cf-81a28bc3d4d3.png#averageHue=%23f2f1f1&clientId=u49230479-29cc-4&from=paste&height=342&id=u73301cdd&originHeight=557&originWidth=688&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=116321&status=done&style=none&taskId=u20cc513a-36ac-4f9c-b474-5dbbe29aad6&title=&width=422.3999938964844)
比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：
```sql
SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5
FROM player JOIN team ON player.team_id = team.team_id # 顺序 1
WHERE height > 1.80 # 顺序 2
GROUP BY player.team_id # 顺序 3
HAVING num > 2 # 顺序 4
ORDER BY num DESC # 顺序 6
LIMIT 2 # 顺序 7
```
在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步 骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。
### （2) SQL的执行原理
SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：

1. 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
2. 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
3. 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。

当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。 
然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。 
当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。 
首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2 。 
当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到 虚拟表 vt6 。 
最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表 vt7 。 
当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。 
同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序，**所谓底层运行的原理，就是我们刚才讲到的执行顺序**。

# 第七章 子查询
## 1.多表查询的需求
表student_info学生的基本信息

| number | name | sex | id_number | department | major | 入学time |
| --- | --- | --- | --- | --- | --- | --- |

表student_score学生的成绩信息

| number | subject | score |
| --- | --- | --- |

截止到目前为止我们介绍的查询语句都是作用于单个表的，但是有时候会有从多个表中查询数据的需求，比如我们想查一下名叫'杜琦燕'的学生的各科成绩该怎么办呢？我们只能先从student_info表中根据名称找到对应的学生学号，然后再通过学号到student_score表中找着对应的成绩信息，所以这个问题的解决方案就是书写两个查询语句：
```sql
mysql> SELECT number FROM student_info WHERE name = '杜琦燕';
+----------+
| number   |
+----------+
| 20180102 |
+----------+
1 row in set (0.00 sec)

mysql> SELECT * FROM student_score WHERE number = 20180102;
+----------+-----------------------------+-------+
| number   | subject                     | score |
+----------+-----------------------------+-------+
| 20180102 | 母猪的产后护理              |   100 |
| 20180102 | 论萨达姆的战争准备          |    98 |
+----------+-----------------------------+-------+
2 rows in set (0.00 sec)

mysql>
```
## 2. 基本使用
我们回过头再仔细看看上述的两条查询语句，第二条查询语句的搜索条件其实是用到了第一条查询语句的查询结果。为了书写简便，我们可以把这两条语句合并到一条语句中，从而减少了把第一条查询语句的结果复制粘贴到第二条查询语句中的步骤，就像这样：
```sql
mysql> SELECT * FROM student_score WHERE number = (SELECT number FROM student_info WHERE name = '杜琦燕');
+----------+-----------------------------+-------+
| number   | subject                     | score |
+----------+-----------------------------+-------+
| 20180102 | 母猪的产后护理              |   100 |
| 20180102 | 论萨达姆的战争准备          |    98 |
+----------+-----------------------------+-------+
2 rows in set (0.01 sec)
```
我们把第二条查询语句用小括号()扩起来作为一个操作数放到了第一条的搜索条件处，这样就起到了合并两条查询语句的作用。小括号中的查询语句也被称为子查询或者内层查询，使用内层查询的结果作为搜索条件的操作数的查询称为外层查询。如果你在一个查询语句中需要用到更多的表的话，那么在一个子查询中可以继续嵌套另一个子查询，在执行查询语句时，将按照从内到外的顺序依次执行这些查询。
```sql
小贴士：

事实上，所有的子查询都必须用小括号扩起来，否则是非法的。
```

- 子查询的基本语法结构：

![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717499925070-16efa346-24d3-4988-8916-566b02d387f1.png#averageHue=%23f2f1c1&clientId=u49230479-29cc-4&from=paste&height=129&id=u05050532&originHeight=202&originWidth=927&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=43280&status=done&style=none&taskId=uef6c05c9-c40b-445a-9737-2ba2e9f4ce4&title=&width=590)

   - 子查询（内查询）在主查询之前一次执行完成。
   - 子查询的结果被主查询（外查询）使用 。
- **注意事项** 
   - 子查询要包含在括号内
   - 将子查询放在比较条件的右侧
   - 单行操作符对应单行子查询，多行操作符对应多行子查询
## 3. 子查询的分类
**分类方式1：**
我们按内查询的结果返回一条还是多条记录，将子查询分为 单行子查询 、 多行子查询 。

- 单行子查询

![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717500009317-aeeedc21-ec51-491f-a3ff-6242e9a156bb.png#averageHue=%23f3e1d4&clientId=u49230479-29cc-4&from=paste&height=102&id=u8c02fa6e&originHeight=168&originWidth=791&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22739&status=done&style=none&taskId=ueb7592fe-7d55-422f-a481-32c5f63708e&title=&width=479.8000183105469)

- 多行子查询

![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717500031981-2b8b22aa-9806-42e4-9923-411121f56805.png#averageHue=%23f3e2d4&clientId=u49230479-29cc-4&from=paste&height=91&id=u2f5eb27d&originHeight=150&originWidth=793&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24148&status=done&style=none&taskId=ue47300ed-8e11-45eb-952d-95fa14dfed5&title=&width=482.4000244140625)
**分类方式2：**
我们按内查询是否被执行多次，将子查询划分为 相关(或关联)子查询 和 不相关(或非关联)子查询 。
子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。
同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。
## 3. 单行子查询
### （1）单行比较操作符
| 操作符 | 含义 |
| --- | --- |
| = | equal to |
| > | greater than |
| >= | greater than or equal to |
| < | less than |
| <= | less than or equal to |
| <> | not equal to |

### （2) 代码示例
**题目：查询工资大于149号员工工资的员工的信息**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717500680024-630f7b27-da48-4a82-a157-9ba4dc0ea88b.png#averageHue=%23ececd4&clientId=u49230479-29cc-4&from=paste&height=356&id=u8543c40e&originHeight=517&originWidth=922&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=82107&status=done&style=none&taskId=ub4891c8b-090b-474a-82e4-d2c68ee1d4e&title=&width=634)

- 题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资
```sql
mysql> SELECT last_name, job_id, salary
    -> FROM employees
    -> WHERE job_id = (
    ->  SELECT job_id
    ->  FROM employees
    ->  WHERE employee_id = 141
    -> )
    -> AND salary > (
    ->  SELECT salary
    ->  FROM employees
    ->  WHERE employee_id = 143
    -> );
+-------------+----------+---------+
| last_name   | job_id   | salary  |
+-------------+----------+---------+
| Nayer       | ST_CLERK | 3200.00 |
| Mikkilineni | ST_CLERK | 2700.00 |
| Bissot      | ST_CLERK | 3300.00 |
| Atkinson    | ST_CLERK | 2800.00 |
| Mallin      | ST_CLERK | 3300.00 |
| Rogers      | ST_CLERK | 2900.00 |
| Ladwig      | ST_CLERK | 3600.00 |
| Stiles      | ST_CLERK | 3200.00 |
| Seo         | ST_CLERK | 2700.00 |
| Rajs        | ST_CLERK | 3500.00 |
| Davies      | ST_CLERK | 3100.00 |
+-------------+----------+---------+
11 rows in set (0.01 sec)
```

- 题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id， manager_id，department_id
```sql
# 实现方式一：不成对比较
SELECT employee_id, manager_id, department_id
FROM employees
WHERE manager_id IN
        (SELECT manager_id
         FROM employees
         WHERE employee_id IN (174,141))
AND department_id IN
        (SELECT department_id
         FROM employees
         WHERE employee_id IN (174,141))
AND employee_id NOT IN(174,141);

# 实现方式二：成对比较
SELECT employee_id, manager_id, department_id
FROM employees
WHERE (manager_id, department_id) IN
/* 在SQL查询中，(manager_id, department_id) 表示一个由两个列组成的元组。
使用括号的目的是为了将这两个列组合在一起进行比较。*/
        (SELECT manager_id, department_id
         FROM employees
         WHERE employee_id IN (141,174))
AND employee_id NOT IN (141,174);
```

- 题目：查询最低工资大于50号部门最低工资的部门id和其最低工资
```sql
SELECT department_id, MIN(salary)
FROM employees
GROUP BY department_id
HAVING MIN(salary) >
            (SELECT MIN(salary)
             FROM employees
             WHERE department_id = 50);
```
### （3) CASE中的子查询
题目：显示员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800 的department_id相同，则location为’Canada’，其余则为’USA’。
```sql
SELECT employee_id, last_name,
    (CASE department_id
     WHEN
     (SELECT department_id FROM departments
         WHERE location_id = 1800)
     THEN 'Canada' ELSE 'USA' END) location
FROM employees;
+-------------+-------------+----------+
| employee_id | last_name   | location |
+-------------+-------------+----------+
|         100 | King        | USA      |
|         101 | Kochhar     | USA      |
|         102 | De Haan     | USA      |
|         103 | Hunold      | USA      |
|         104 | Ernst       | USA      |
|         105 | Austin      | USA      |
|         106 | Pataballa   | USA      |
|         107 | Lorentz     | USA      |
|         108 | Greenberg   | USA      |
……
```
这段SQL代码的目的是根据 `employees` 表中员工的 `department_id`，来确定他们的工作地点是 "Canada" 还是 "USA"。我们逐步分析这段代码：

1.  **选择列**： 
```sql
SELECT employee_id, last_name,
```

这里选择了两个列：`employee_id` 和 `last_name`，用于显示员工的ID和姓氏。 

2.  **CASE表达式**： 
```sql
(CASE department_id
WHEN
    (SELECT department_id FROM departments
    WHERE location_id = 1800)
THEN 'Canada' ELSE 'USA' END) location
```

这部分代码使用了 `CASE` 表达式来确定每个员工的工作地点。具体步骤如下： 

   - `CASE department_id`：根据每个员工的 `department_id` 进行判断。
   - `WHEN (SELECT department_id FROM departments WHERE location_id = 1800)`：这是一个子查询，返回 `departments` 表中 `location_id` 为1800的 `department_id`。
   - `THEN 'Canada'`：如果员工的 `department_id` 等于子查询返回的 `department_id`，那么这个员工的工作地点为 "Canada"。
   - `ELSE 'USA'`：否则，员工的工作地点为 "USA"。
   - `END`：结束 `CASE` 表达式。
   - `location`：给这个计算列起一个别名 `location`。
3.  **完整查询**： 
```sql
FROM employees;
```

数据来源是 `employees` 表。 
总结一下，这段SQL代码从 `employees` 表中选择 `employee_id`、`last_name` 和计算出的 `location`。`location` 是根据员工的 `department_id` 判断的，如果 `department_id` 属于 `location_id` 为1800的部门，则 `location` 显示为 "Canada"，否则为 "USA"。
### （4) 子查询中的空值问题
```sql
mysql> SELECT last_name, job_id
    -> FROM employees
    -> WHERE job_id =
    ->     (SELECT job_id
            ->     FROM employees
            ->     WHERE last_name = 'Haas');
Empty set (0.00 sec)
```
> 子查询不返回任何行

### （5) 非法使用子查询
```sql
mysql> SELECT employee_id, last_name
    -> FROM employees
    -> WHERE salary =
    ->       (SELECT MIN(salary)
              ->       FROM employees
              ->       GROUP BY department_id);
ERROR 1242 (21000): Subquery returns more than 1 row
```
**为什么非法使用子查询了**
多行子查询使用单行比较符
这段SQL代码非法使用子查询的原因在于，子查询 `(SELECT MIN(salary) FROM employees GROUP BY department_id)` 返回多个结果，而主查询期望子查询返回一个单一值来进行比较。这种情况下，主查询中的 `WHERE salary =` 无法处理多个值。
让我们具体分析：

1.  **子查询部分**： 
```sql
(SELECT MIN(salary) FROM employees GROUP BY department_id)
```
这段子查询根据 `department_id` 对员工的 `salary` 进行分组，并返回每个部门中最低的薪水。这意味着子查询可能会返回多个 `MIN(salary)` 的值（每个部门一个值）。 

2.  **主查询部分**： 
```sql
WHERE salary = (SELECT MIN(salary) FROM employees GROUP BY department_id)
```
主查询尝试将 `salary` 与子查询返回的多个值进行比较，但 `=` 运算符只适用于单一值的比较。因此，这种用法是非法的，因为它产生了逻辑错误。 
## 4. 多行子查询

- 也称为集合比较子查询
- 内查询返回多行
- 使用多行比较操作符
### （1) 多行比较操作符
| 操作符 | 含义 |
| --- | --- |
| IN | 等于列表中的**任意一个** |
| ANY | 需要和单行比较操作符一起使用，和子查询返回的**任意一个**值比较 |
| ALL | 需要和单行比较操作符一起使用，和子查询返回的**所有**值比较 |
| SOME | 实际上是ANY的别名，作用相同，一般常使用ANY |

### （2) 代码示例

- 题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary
```sql
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE job_id <> 'IT_PROG' 
AND salary < ANY(
  SELECT salary
  FROM employees
  WHERE job_id = 'IT_PROG'
);
+-------------+-------------+------------+---------+
| employe
……e_id | last_name   | job_id     | salary  |
+-------------+-------------+------------+---------+
|         110 | Chen        | FI_ACCOUNT | 8200.00 |
|         111 | Sciarra     | FI_ACCOUNT | 7700.00 |
|         112 | Urman       | FI_ACCOUNT | 7800.00 |
|         113 | Popp        | FI_ACCOUNT | 6900.00 |
|         115 | Khoo        | PU_CLERK   | 3100.00 |
|         116 | Baida       | PU_CLERK   | 2900.00 |
……
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717662829579-a33e054d-e181-4704-8c5e-909f2554402b.png#averageHue=%23f0eebe&clientId=u0666c989-e1f9-4&from=paste&height=227&id=ub0862d62&originHeight=284&originWidth=925&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=89607&status=done&style=none&taskId=u6df8e547-5904-430f-951a-fe178b19685&title=&width=740)
分析这段代码：
这段SQL代码的目的是找出 **job_id** 不是 'IT_PROG' 且工资低于 'IT_PROG' 部门任一工资的员工信息。我们逐步分析这段代码：
（1）主查询部分
```sql
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE job_id <> 'IT_PROG'
AND salary < ANY(
```

- **SELECT employee_id, last_name, job_id, salary**：选择员工的编号、姓氏、职位ID和薪水。
- **FROM employees**：从 **employees** 表中提取数据。
- **WHERE job_id <> 'IT_PROG'**：条件是职位ID不是 'IT_PROG'。

（2）子查询部分
```sql
SELECT salary
FROM employees
WHERE job_id = 'IT_PROG'
)
```

- **SELECT salary FROM employees WHERE job_id = 'IT_PROG'**：子查询返回所有 'IT_PROG' 部门员工的薪水。

（3）使用 **ANY** 关键字
```sql
AND salary < ANY(
```

- **AND salary < ANY(...)**：表示主查询中的 **salary** 要小于子查询返回的任意一个 **salary** 值。**ANY** 关键字表示如果主查询中的 **salary** 小于子查询结果中的任何一个值，那么条件就满足。

**分析**

1. **主查询和子查询的关系**：
   - 主查询的 **WHERE** 子句检查 **job_id** 不是 'IT_PROG' 的员工。
   - 子查询返回所有 **job_id** 为 'IT_PROG' 的员工的工资列表。
2. **比较逻辑**：
   - 使用 **salary < ANY (...)** 比较主查询中的 **salary** 是否小于子查询结果中的任何一个 **salary**。如果是，则该记录满足条件。
- 题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及salary
```sql
mysql> SELECT employee_id, last_name, job_id, salary
    -> FROM employees
    -> WHERE job_id <> 'IT_PROG'
    -> AND salary < ALL(
    -> SELECT salary
    ->   FROM employees
    ->   WHERE job_id = 'IT_PROG'
    -> );
+-------------+-------------+----------+---------+
| employee_id | last_name   | job_id   | salary  |
+-------------+-------------+----------+---------+
|         115 | Khoo        | PU_CLERK | 3100.00 |
|         116 | Baida       | PU_CLERK | 2900.00 |
|         117 | Tobias      | PU_CLERK | 2800.00 |
|         118 | Himuro      | PU_CLERK | 2600.00 |
|         119 | Colmenares  | PU_CLERK | 2500.00 |
|         125 | Nayer       | ST_CLERK | 3200.00 |
|         126 | Mikkilineni | ST_CLERK | 2700.00 |
|         127 | Landry      | ST_CLERK | 2400.00 |
……
```

- 题目：查询平均工资最低的部门id
```sql
#方式1：
SELECT department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary) = (
  SELECT MIN(avg_sal)
  FROM (
    SELECT AVG(salary) avg_sal
    FROM employees
    GROUP BY department_id
  ) dept_avg_sal
);
```
代码分析：
![4b701ff0ce25ca1d0a89897814b2aac5.jpg](https://cdn.nlark.com/yuque/0/2024/jpeg/33643071/1717664331542-ee7d18d0-9b29-4fab-a5cf-9f81b0234459.jpeg#averageHue=%23f5f2ef&clientId=u0666c989-e1f9-4&from=paste&height=834&id=u0afd35bf&originHeight=1042&originWidth=1680&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=871897&status=done&style=none&taskId=u5110d844-5557-45bf-9ceb-c3f923b25fa&title=&width=1344)
```sql
#方式2：
SELECT department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary) <= ALL (
  SELECT AVG(salary) avg_sal
  FROM employees
  GROUP BY department_id
);
+---------------+
| department_id |
+---------------+
|            50 |
+---------------+
1 row in set (0.00 sec)
```
### （3) 空值问题
```sql
mysql> SELECT last_name
    -> FROM employees
    -> WHERE employee_id NOT IN (
    ->     SELECT manager_id
    ->     FROM employees
    -> );
Empty set (0.01 sec)
```
总体逻辑

1. **内层子查询**：
   - 内层子查询返回 employees 表中所有的 manager_id，即所有在 employees 表中列为经理的员工 ID。
   - 生成一列所有经理的 ID。
2. **外层查询**：
   - 外层查询查找 employees 表中 employee_id 不在内层子查询返回的经理 ID 列表中的员工。
   - 换句话说，查找那些不是任何人的经理的员工。
   - 然后选择这些员工的 last_name。
## 5. 相关子查询
如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件 关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。
相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717664878515-34f73128-509a-467e-9dc3-d4d2859bc880.png#averageHue=%23a1bb62&clientId=u0666c989-e1f9-4&from=paste&height=251&id=u3bbe2e8c&originHeight=389&originWidth=611&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=61015&status=done&style=none&taskId=uc4960193-bf67-4f69-a84a-e3b105e0716&title=&width=393.8000183105469)
![](MySQL%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20220603154919387.png#id=eRneF&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717664924980-948e920a-6abb-4d0a-b231-e9c549a0f216.png#averageHue=%23f2f2c2&clientId=u0666c989-e1f9-4&from=paste&height=210&id=u5603ca90&originHeight=262&originWidth=920&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=66640&status=done&style=none&taskId=u18768cc9-00e6-4198-b145-9b16b1bb751&title=&width=736)
![](MySQL%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20220603155013864.png#id=Uzm7W&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)说明：**子查询中使用主查询中的列**
比方说我们想查看一些学生的基本信息，但是前提是这些学生在student_score表中有成绩记录，那可以这么写：
```sql
SELECT number, name, id_number, major 
FROM student_info 
WHERE EXISTS (
  SELECT * 
  FROM student_score 
  WHERE student_score.number = student_info.number
);
+----------+-----------+--------------------+--------------------------+
| number   | name      | id_number          | major                    |
+----------+-----------+--------------------+--------------------------+
| 20180101 | 杜子腾    | 158177199901044792 | 计算机科学与工程         |
| 20180102 | 杜琦燕    | 151008199801178529 | 计算机科学与工程         |
| 20180103 | 范统      | 17156319980116959X | 软件工程                 |
| 20180104 | 史珍香    | 141992199701078600 | 软件工程                 |
+----------+-----------+--------------------+--------------------------+
4 rows in set (0.00 sec)

mysql>

```
逻辑解析：
1.执行流程：

- 对于 student_info 表中的每一行，执行子查询以检查 student_score 表中是否存在具有相同 number 的记录。
- 如果子查询返回一条或多条记录，则 EXISTS 子句返回 TRUE，否则返回 FALSE。
- 主查询只保留那些使 EXISTS 子查询返回 TRUE 的 student_info 记录。

2.功能：

- 这段代码有效地过滤出在 student_score 表中有成绩记录的学生信息。
- 换句话说，只有那些在 student_score 表中存在对应 number 的学生才会被主查询返回。
```sql
小贴士：

student_info和student_score表里都有number列，
所以在子查询的WHERE语句中书写number = number会造成二义性，
也就是让服务器懵逼，不知道这个number列到底是哪个表的，
所以为了区分，在列名前边加上了表名，并用点.连接起来，
这种显式的将列所属的表名书写出来的名称称为该列的全限定名。
所以上边子查询的WHERE语句中用了列的全限定名：student_score.number = student_info.number。

```
这条查询语句可以分成这么两部分来理解

- 我们要查询学生的一些基本信息。
- 这些学生必须符合这样的条件：必须有成绩记录保存在student_score表中。

所以这个例子中的相关子查询的查询过程是这样的：

- 先执行外层查询获得到student_info表的第一条记录，发现它的number值是20180101。把20180101当作参数传入到子查询，此时子查询的意思是判断student_score表的number字段是否有20180101这个值存在，子查询的结果是该值存在，所以整个EXISTS表达式的值为TRUE，那么student_info表的第一条记录可以被加入到结果集。
- 再执行外层查询获得到student_info表的第二条记录，发现它的number值是20180102，与上边的步骤相同，student_info表的第二条记录也可以被加入到结果集。
- 与上边类似，student_info表的第三条记录也可以被加入到结果集。
- 与上边类似，student_info表的第四条记录也可以被加入到结果集。
- 再执行外层查询获得到student_info表的第五条记录，发现它的number值是20180105，把20180105当作参数传入到它的子查询，此时子查询的意思是判断student_score表的number字段是否有20180105这个值存在，子查询的结果是该值不存在，所以整个EXISTS表达式的值为FALSE，那么student_info表的第五条记录就不被加入结果集中。
- 与上一步骤类似，student_info表的第六条记录也不被加入结果集中。
- student_info表没有更多的记录了，结束查询。
### （1) 代码示例

- 题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id
```sql
# 方式一：使用相关子查询
SELECT last_name, salary, department_id
FROM employees e1
WHERE salary > (
		SELECT AVG(salary)
    	FROM employees e2
    	WHERE department_id = e1.department_id
);
```
代码分析：
执行流程
1.外部查询中的每一行：

- 外部查询（假设表为 e1）逐行处理 employees 表中的数据。

2.子查询执行：

- 对于外部查询的当前行，执行子查询。
- 子查询从 employees 表中选择所有 department_id 等于当前行 department_id 的行。
- 然后，子查询计算这些行的 salary 的平均值。

3.返回结果：

- 子查询计算的平均值作为外部查询的一个比较值，或者用于外部查询的其他操作。
```sql
# 方式二：在FROM中声明子查询
SELECT e.last_name, e.salary, e.department_id
FROM employees e, (
  SELECT department_id, AVG(salary) avg_sal
  FROM employees
  GROUP BY department_id) t_dept_avg_salary
WHERE e.department_id = t_dept_avg_salary.department_id
AND e.salary > t_dept_avg_salary.avg_sal;
```
**在ORDER BY 中使用子查询：**

- 题目：查询员工的id,salary,按照department_name 排序
```sql
mysql> SELECT employee_id, salary
    -> FROM employees e
    -> ORDER BY (
    ->   SELECT department_name
    ->   FROM departments d
    ->   WHERE e.`department_id` = d.`department_id`
    -> );
+-------------+----------+
| employee_id | salary   |
+-------------+----------+
|         178 |  7000.00 |
|         205 | 12000.00 |
|         206 |  8300.00 |
|         200 |  4400.00 |
|         100 | 24000.00 |
……
```
针对于ORDER BY:
在 SQL 中，**ORDER BY** 子句可以使用子查询返回的值进行排序。虽然子查询在每次执行时只返回一个值，但由于它是在主查询的每一行上执行的，因此它实际上会针对主查询中的每一行返回不同的值。这样一来，主查询的每一行都可以有一个与之相关的子查询返回值，**ORDER BY** 子句就可以根据这些值进行排序。

- **题目：**若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同 id的员工的employee_id,last_name和其job_id
```sql
mysql> SELECT e.employee_id, last_name,e.job_id
    -> FROM employees e
    -> WHERE 2 <= (SELECT COUNT(*)
                   ->         FROM job_history
                   ->         WHERE employee_id = e.employee_id
                   -> );
+-------------+-----------+---------+
| employee_id | last_name | job_id  |
+-------------+-----------+---------+
|         101 | Kochhar   | AD_VP   |
|         176 | Taylor    | SA_REP  |
|         200 | Whalen    | AD_ASST |
+-------------+-----------+---------+
3 rows in set (0.01 sec)
```
### （2) EXISTS 与 NOT EXISTS 关键字

- 关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。
- **如果在子查询中不存在满足条件的行： **
   - 条件返回 FALSE
   - 继续在子查询中查找
- **如果在子查询中存在满足条件的行： **
   - 不在子查询中继续查找
   - 条件返回 TRUE
- NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。
- **题目：**查询公司管理者的employee_id，last_name，job_id，department_id信息
```sql
# 方式一：EXISTS
SELECT employee_id, last_name, job_id, department_id
FROM employees e1
WHERE EXISTS ( SELECT *
        FROM employees e2
        WHERE e2.manager_id =
        e1.employee_id
);
```
```sql
# 方式二：自连接
SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_id
FROM employees e1 JOIN employees e2
ON e1.employee_id = e2.manager_id;
```
分析代码：
1. SELECT DISTINCT 子句

- **SELECT DISTINCT** 确保查询结果中每行是唯一的，去除了重复记录。
- 选择的列包括 **e1.employee_id**、**e1.last_name**、**e1.job_id** 和 **e1.department_id**。

2. FROM 和 JOIN 子句

- **FROM employees e1** 指定查询的数据来源于 **employees** 表，并为其起了一个别名 **e1**。
- **JOIN employees e2** 表示执行内连接（INNER JOIN），将 **employees** 表再次加入查询，并为其起了别名 **e2**。
- **ON e1.employee_id = e2.manager_id** 指定连接条件：**e1.employee_id** 必须等于 **e2.manager_id**，这意味着 **e1** 表中代表经理的员工ID必须等于 **e2** 表中代表员工的经理ID。

执行过程

1. **连接操作**：
   - 内连接 **JOIN** 基于 **e1.employee_id = e2.manager_id** 条件，将 **employees** 表中的每一行与另一行进行匹配。
   - 只有 **e1.employee_id** 等于 **e2.manager_id** 的行才会出现在结果集中。
2. **去重操作**：
   - **DISTINCT** 确保结果集中没有重复的员工记录，即每个经理只出现一次。
```sql
# 方式三：IN
SELECT employee_id, last_name, job_id, department_id
WHERE employee_id IN (
        SELECT DISTINCT manager_id
        FROM employees
);
```

- **题目**：查询departments表中，不存在于employees表中的部门的department_id和department_name
```sql
# 方式一：
SELECT d.department_id, d.department_name
FROM departments e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE e.`department_id` IS NULL;

# 方式二：
SELECT department_id, department_name
FROM departments d
WHERE NOT EXISTS (
  SELECT *
  FROM employees e
  WHERE d.`department_id` = e.`department_id`
);
```
### （3) 相关更新
```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

- **table_name**：要更新的表的名称。
- **SET**：指定要更新的列和新值。
- **WHERE**：指定哪些行需要更新（如果省略，则更新表中的所有行）。

使用相关子查询依据一个表中的数据更新另一个表的数据。
```sql
UPDATE table1 alias1 # alias是别名的意思
SET column = (SELECT expression
              FROM table2 alias2
              WHERE alias1.column = alias2.column);
```

- **题目**：在employees中增加一个department_name字段，数据为员工对应的部门名称
```sql
# 1）
ALTER TABLE employees
ADD(department_name VARCHAR2(14));
```
代码分析：
关键点分析

1. **ALTER TABLE 语句**：
   - **ALTER TABLE** 语句用于修改已存在的表的结构，比如添加或删除列，修改列的数据类型，重命名列或表等。
2. **指定表名**：
   - **employees**：这是要修改的表的名称。
3. **ADD 子句**：
   - **ADD** 子句用于向表中添加新列。
   - 新列的定义在括号内。
4. **新列的定义**：
   - **department_name**：这是新添加的列的名称。
   - **VARCHAR2(14)**：这是新列的数据类型和长度。
      - **VARCHAR2** 是可变长度字符数据类型，通常用于存储字符串。
      - **(14)** 指定了字符串的最大长度为14个字符。

详细解析
1. 修改表结构
**ALTER TABLE employees** 语句指定了要修改的表是 **employees**。这是修改表结构的起始点。
2. 添加新列
**ADD (department_name VARCHAR2(14))** 子句指示数据库管理系统在 **employees** 表中添加一个名为 **department_name** 的新列，并且这个列的数据类型为 **VARCHAR2**，最大长度为14个字符。
```sql
# 2）
UPDATE employees e
SET department_name = (SELECT department_name
FROM departments d
WHERE e.department_id = d.department_id);
```
代码分析：
关键点分析

1. **UPDATE 语句**：
   - **UPDATE** 语句用于修改表中的数据。在这里，目标表是 **employees** 表，别名为 **e**。
2. **SET 子句**：
   - **SET department_name =** 指定要更新的列是 **department_name**，其新值来自子查询的结果。
3. **子查询**：
   - 子查询从 **departments** 表中选择 **department_name** 列。
   - 子查询使用 **WHERE e.department_id = d.department_id** 条件，以确保 **employees** 表中的 **department_id** 和 **departments** 表中的 **department_id** 匹配。

执行过程

1. **主查询执行**：
   - 对 **employees** 表中的每一行，执行子查询。
2. **子查询执行**：
   - 子查询在 **departments** 表中查找 **department_id** 与当前 **employees** 表中的行的 **department_id** 相匹配的记录，并返回对应的 **department_name**。
3. **更新操作**：
   - 将子查询返回的 **department_name** 值赋给 **employees** 表中当前行的 **department_name** 列。
### （4) 相关删除
SQL 中的删除操作主要通过 **DELETE** 语句来实现，用于从表中删除一行或多行数据。相关删除（Correlated Delete）通常涉及子查询，用于基于其他表的数据删除指定的行。以下是对 SQL 中删除操作的详细介绍。
**基本语法**
```sql
sql
复制代码
DELETE FROM table_name
WHERE condition;
```

- **table_name**：要删除数据的表的名称。
- **WHERE**：指定需要删除的行的条件。如果省略 **WHERE** 子句，则删除表中的所有行。
- 使用相关子查询依据一个表中的数据删除另一个表的数据。
```sql
DELETE FROM table1 alias1
WHERE column operator (SELECT expression
                       FROM table2 alias2
                       WHERE alias1.column = alias2.column);
```

- **题目**：删除 **employees** 表中那些在 **emp_history** 表中也存在的员工记录
```sql
DELETE FROM employees e
WHERE employee_id in(
  SELECT employee_id
  FROM emp_history
  WHERE employee_id = e.employee_id
);
```
分析代码：
这段SQL代码的功能是删除 `employees` 表中那些在 `emp_history` 表中也存在的员工记录。我们可以逐步分析这段代码的结构和功能。
关键点分析

1.  **DELETE 语句**： 
   - `DELETE` 语句用于从表中删除数据。在这里，目标表是 `employees`，并为其起了别名 `e`。
2.  **WHERE 子句**： 
   - `WHERE` 子句指定需要删除的行的条件。在这里，我们使用了 `IN` 子句。
3.  **子查询**： 
   - 子查询从 `emp_history` 表中选择 `employee_id` 列。
   - 子查询使用 `WHERE employee_id = e.employee_id` 条件，以确保 `emp_history` 表中的 `employee_id` 与 `employees` 表中的 `employee_id` 相匹配。

执行过程

1.  **子查询执行**： 
   - 子查询从 `emp_history` 表中选择所有与当前 `employees` 表中的行的 `employee_id` 相匹配的 `employee_id`。
2.  **主查询执行**： 
   - 主查询使用 `IN` 子句来检查 `employees` 表中的每一行的 `employee_id` 是否存在于子查询返回的结果集中。
   - 如果存在，则删除该行。

示例数据
假设有以下表：
`**employees**`** 表：**

| employee_id | first_name | last_name | salary | department_id |
| --- | --- | --- | --- | --- |
| 1 | John | Smith | 5000 | 10 |
| 2 | Jane | Doe | 3000 | 20 |
| 3 | John | Doe | 4000 | 10 |
| 4 | Mary | Johnson | 6000 | 30 |
| 5 | Jane | Smith | 7000 | 20 |

`**emp_history**`** 表：**

| employee_id | position | start_date | end_date |
| --- | --- | --- | --- |
| 1 | Manager | 2010-01-01 | 2015-01-01 |
| 3 | Analyst | 2012-06-01 | 2018-06-01 |
| 5 | Developer | 2014-09-01 | 2019-09-01 |

删除过程

1.  **子查询结果**： 
   - 子查询返回 `emp_history` 表中存在的 `employee_id` 列表：
```sql
SELECT employee_id
FROM emp_history
WHERE employee_id = e.employee_id;
```
 结果为： 

| employee_id |
| --- |
| 1 |
| 3 |
| 5 |

2.  **主查询删除**： 
   - 主查询检查 `employees` 表中的每一行，`employee_id` 是否存在于子查询返回的结果集中：
```sql
DELETE FROM employees
WHERE employee_id IN (1, 3, 5);
```

3.  **删除符合条件的行**： 
   - `employee_id` 为 1, 3, 5 的行将被删除。

删除后的 `employees` 表：

| employee_id | first_name | last_name | salary | department_id |
| --- | --- | --- | --- | --- |
| 2 | Jane | Doe | 3000 | 20 |
| 4 | Mary | Johnson | 6000 | 30 |

## 6. 思考题
问题：谁的工资比Abel的高？ 解答：
```sql
#方式1：自连接
SELECT e2.last_name,e2.salary
FROM employees e1,employees e2
WHERE e1.last_name = 'Abel'
AND e1.`salary` < e2.`salary`;
```
```sql
#方式2：子查询
SELECT last_name,salary
FROM employees
WHERE salary > (
  SELECT salary
  FROM employees
  WHERE last_name = 'Abel'
);
```
问题：以上两种方式有好坏之分吗？
解答：自连接方式好！
题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过 程中，对于自连接的处理速度要比子查询快得多。 可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表 进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。
# 第八章 创建和管理表
## 1. 基础知识
### （1）一条数据存储的过程
存储数据是处理数据的第一步 。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。
那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717673352377-69d5da09-941a-4721-82d3-927b8a95cc5b.png#averageHue=%23dbe6cf&clientId=u0666c989-e1f9-4&from=paste&height=127&id=uaa59c634&originHeight=159&originWidth=904&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=53124&status=done&style=none&taskId=u19acbdbb-70d3-48b4-84aa-75261af1e9b&title=&width=723.2)
我们要先创建一个数据库，而不是直接创建数据表呢？
因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是 数据库服务器 、 数据库 、 数据表 、数据表的 行与列 。
MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。
### （2) 标识符命名规则

- 数据库名、表名不得超过30个字符，变量名限制为29个
- 必须只能包含 A–Z, a–z, 0–9, _共63个字符
- 数据库名、表名、字段名等对象名中间不要包含空格
- 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名
- 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来
- 保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了
### （2) MySQL中的数据类型
| 类型 | 数据变量 |
| --- | --- |
| 整数类型 | TINYINT、SMALLINT、MEDIUMINT、**INT(或INTEGER)**、BIGINT |
| 浮点类型 | FLOAT、DOUBLE |
| 定点数类型 | **DECIMAL** |
| 位类型 | BIT |
| 日期时间类型 | YEAR、TIME、DATE、DATETIME、TIMESTAMP |
| 文本字符串类型 | CHAR、**VARCHAR**、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT |
| 枚举类型 | ENUM |
| 集合类型 | SET |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB |
| JSON类型 | JSON对象、JSON数组 |
| 空间数据类型 | 单值：GEOMETRY、POINT、LINESTRING、POLYGON； 集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION |

其中，常用的几类类型介绍如下：

| 数据类型 | 描述 |
| --- | --- |
| INT | 从-231到231-1的整型数据。存储大小为 4个字节 |
| CHAR(size) | 定长字符数据。若未指定，默认为1个字符，最大长度255 |
| VARCHAR(size) | 可变长字符数据，根据字符串实际长度保存，**必须指定长度** |
| FLOAT(M,D) | 单精度，占用4个字节，M=整数位+小数位，D=小数位。 D<=M<=255,0<=D<=30，默认M+D<=6 |
| DOUBLE(M,D) | 双精度，占用8个字节，D<=M<=255,0<=D<=30，默认M+D<=15 |
| DECIMAL(M,D) | 高精度小数，占用M+2个字节，D<=M<=65，0<=D<=30，最大取值范围与DOUBLE相同。 |
| DATE | 日期型数据，格式'YYYY-MM-DD' |
| BLOB | 二进制形式的长文本数据，最大可达4G |
| TEXT | 长文本数据，最大可达4G |

## 2. 创建和管理数据库
### （1) 创建数据库

-  方式1：创建数据库 
```sql
CREATE DATABASE 数据库名;
```

-  方式2：创建数据库并指定字符集 
```sql
CREATE DATABASE 数据库名 CHARACTER SET 字符集;
```
**分析：指定字符集**
指定字符集并不意味着数据库只能使用指定的字符集，而是指默认情况下，该数据库会使用指定的字符集进行数据存储和处理。然而，数据库中的具体表、列或连接可以使用不同的字符集。让我们更详细地解释这个概念。
**指定字符集的意义**

1. **默认字符集**：
   - 当在创建数据库时指定字符集，这个字符集成为数据库的默认字符集。所有未显式指定字符集的表和列将继承这个默认字符集。
2. **表和列的字符集**：
   - 尽管数据库有一个默认字符集，但你可以在创建表或列时指定不同的字符集。
3. **连接字符集**：
   - 客户端与数据库服务器之间的连接也可以指定字符集，这样可以确保数据在传输过程中不发生字符编码问题。
-  方式3：判断数据库是否已经存在，不存在则创建数据库（ 推荐 ） 
```sql
CREATE DATABASE IF NOT EXISTS 数据库名;
```
如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。
> 注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删 旧库完成的。
> 解释：这句话解释了在大多数数据库管理系统中，数据库本身不能直接通过SQL命令进行重命名的限制。相反，一些可视化数据库管理工具（如phpMyAdmin、pgAdmin或SQL Server Management Studio）提供了“重命名”数据库的功能，但它们实现这一功能的方式实际上是通过创建一个新数据库，将原数据库的所有表和数据复制到新数据库中，然后删除旧数据库。
> 让我们详细解释这句话的含义和背后的操作步骤：
> **1. DATABASE 不能改名**
> 在许多数据库管理系统（DBMS）中，没有直接的SQL命令可以重命名数据库。例如，MySQL和PostgreSQL都没有提供重命名数据库的直接SQL命令。
> **2. 可视化工具的“改名”功能**
> 一些可视化工具提供了“重命名”数据库的选项，这些工具通常会通过以下步骤来模拟数据库重命名：
> 1. **创建新数据库**：创建一个与旧数据库结构相同的新数据库，但使用新的名称。
> 2. **复制数据**：将旧数据库中的所有表、数据、索引、约束等复制到新数据库中。
> 3. **删除旧数据库**：在确保所有数据和结构已成功复制后，删除旧的数据库。

### （2）使用数据库

-  查看当前所有的数据库 
```sql
SHOW DATABASES; #有一个S，代表多个数据库
```

-  查看当前正在使用的数据库 
```sql
SELECT DATABASE(); #使用的一个 mysql 中的全局函数
```

-  查看指定库下所有的表 
```sql
SHOW TABLES FROM 数据库名
```

-  查看数据库的创建信息 
```sql
SHOW CREATE DATABASE 数据库名;
或者：
SHOW CREATE DATABASE 数据库名\G
```
 在SQL中，查看数据库的创建信息通常是指检索有关数据库的元数据，这些元数据可以包括数据库的名称、创建时间、字符集、排序规则等。这些信息对于数据库管理员来说是非常重要的，因为它们可以帮助了解数据库的配置和状态，确保数据库的正确管理和维护。
不同的数据库管理系统（DBMS）提供不同的方法来查看这些创建信息。
举例：
```sql
mysql> SHOW CREATE DATABASE atguigudb;
+-----------+----------------------------------------------------------------------------------------------------------+
| Database  | Create Database                                                                                          |
+-----------+----------------------------------------------------------------------------------------------------------+
| atguigudb | CREATE DATABASE `atguigudb` /*!40100 DEFAULT CHARACTER SET utf8mb3 */ /*!80016 DEFAULT ENCRYPTION='N' */ |
+-----------+----------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```

-  使用/切换数据库 
```sql
USE 数据库名;
```
> 注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数 据库名.”。

### （3) 修改数据库

-  更改数据库字符集 
```sql
ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等
```
### （4）删除数据库

-  方式1：删除指定的数据库 
```sql
DROP DATABASE 数据库名;
```

-  方式2：删除指定的数据库（ 推荐 ） 
```sql
DROP DATABASE IF EXISTS 数据库名;
```
## 3. 创建表
### （1) 创建方式1

- 必须具备
   - CREATE TABLE权限
   - 存储空间
- 语法格式：
```sql
CREATE TABLE [IF NOT EXISTS] 表名 (
    列名1 数据类型 [列的属性] [默认值],
    列名2 数据类型 [列的属性] [默认值],
    ...
    列名n 数据类型 [列的属性] [默认值],
    [表约束条件]
);

```
> 加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表； 如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。

- **必须指定：**
   - 表名
   - 列名(或字段名)，数据类型，**长度**
- **可选指定：**
   - 约束条件
   - 默认值

举例：
```sql
mysql> CREATE TABLE emp (
    ->   emp_id INT,                   -- int类型
    ->   emp_name VARCHAR(20),         -- 最多保存20个中英文字符
    ->   salary DOUBLE,                -- 总位数不超过15位
    ->   birthday DATE                 -- 日期类型
    -> );
Query OK, 0 rows affected (0.03 sec)

mysql> DESC emp;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| emp_id   | int         | YES  |     | NULL    |       |
| emp_name | varchar(20) | YES  |     | NULL    |       |
| salary   | double      | YES  |     | NULL    |       |
| birthday | date        | YES  |     | NULL    |       |
+----------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```
MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。
```sql
mysql> CREATE TABLE dept (
    ->   deptno INT(2) AUTO_INCREMENT,  -- int类型，自增
    ->   dname VARCHAR(14),
    ->   loc VARCHAR(13),
    ->   PRIMARY KEY (deptno)           -- 主键
    -> );
Query OK, 0 rows affected, 1 warning (0.03 sec)

mysql> DESCRIBE dept;
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1717676021307-7241ae85-bfc5-40eb-91f9-dd4ffd055b24.png#averageHue=%23cac4b4&clientId=u0666c989-e1f9-4&from=paste&height=88&id=u9b96b810&originHeight=110&originWidth=931&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=50826&status=done&style=none&taskId=uf929f56e-90e7-4c30-9afe-7367f51f30c&title=&width=744.8)
> 在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。

### （2) 创建方式2

- 使用 AS subquery 选项，**将创建表和插入数据结合起来**
```sql
CREATE TABLE 表名
	[(column, column, ...)]
AS subquery;
```

- 指定的列和子查询中的列要一一对应
- 通过列名和默认值定义列
```sql
 CREATE TABLE emp1 AS SELECT * FROM employees;
```
**分析代码：**
这句SQL代码的功能是创建一个名为 **emp1** 的新表，并将 **employees** 表中的所有数据复制到 **emp1** 表中。以下是对这句代码的详细分析：
**一、关键点分析**

1. **CREATE TABLE emp1 AS SELECT ...**：
   - 这是一种快速创建新表并复制数据的方法。
   - **emp1** 是新创建的表名。
   - **AS SELECT * FROM employees** 表示新表 **emp1** 的结构将基于 **employees** 表，并且将复制 **employees** 表中的所有数据。

**二、执行过程**

1. **创建表结构**：
   - **emp1** 表的列结构将基于 **employees** 表的当前列。
   - 这意味着新表 **emp1** 将包含与 **employees** 表相同的列名和数据类型，但不会包含 **employees** 表的索引、约束、主键和默认值。
2. **复制数据**：
   - 执行 **SELECT * FROM employees**，将查询到的所有数据插入到 **emp1** 表中。
   - **emp1** 表中的数据将与 **employees** 表中的数据完全相同，但结构方面没有约束和索引。
```sql
CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表
```
**分析代码：**
这句SQL代码的功能是创建一个名为 **emp2** 的新表，其结构与 **employees** 表相同，但不包含任何数据。让我们详细分析这句代码。
**一、关键点分析**

1. **CREATE TABLE emp2 AS SELECT ...**：
   - **CREATE TABLE emp2** 表示创建一个名为 **emp2** 的新表。
   - **AS SELECT * FROM employees** 表示新表 **emp2** 的列结构将基于 **employees** 表。
   - **WHERE 1=2** 是一个总是返回 **FALSE** 的条件，这确保了没有数据被插入到新表中。

**二、执行过程**

1. **创建表结构**：
   - **emp2** 表的列结构将完全基于 **employees** 表。新表 **emp2** 将包含与 **employees** 表相同的列名和数据类型。
   - 由于 **WHERE 1=2** 条件总是 **FALSE**，**SELECT** 语句不会返回任何数据行，因此 **emp2** 表将是一个空表。
2. **不复制数据**：
   - **WHERE 1=2** 确保没有数据被复制到新表 **emp2** 中。这个条件在逻辑上总是不成立，所以没有数据满足这个条件。
```sql
CREATE TABLE dept80
AS
SELECT employee_id, last_name, salary*12 ANNSAL, hire_date
FROM employees
WHERE department_id = 80;
```
### （3）查看数据表结构
在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用 DESCRIBE/DESC 语句查看数据 表结构，也支持使用 SHOW CREATE TABLE 语句查看数据表结构。
语法格式如下：
```sql
SHOW CREATE TABLE 表名\G
```
举例：
```sql
mysql> SHOW CREATE TABLE employees;
+-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table     | Create Table







                             |
+-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| employees | CREATE TABLE `employees` (
  `employee_id` int NOT NULL DEFAULT '0',
  `first_name` varchar(20) DEFAULT NULL,
  `last_name` varchar(25) NOT NULL,
  `email` varchar(25) NOT NULL,
  `phone_number` varchar(20) DEFAULT NULL,
  `hire_date` date NOT NULL,
  `job_id` varchar(10) NOT NULL,
  `salary` double(8,2) DEFAULT NULL,
  `commission_pct` double(2,2) DEFAULT NULL,
  `manager_id` int DEFAULT NULL,
  `department_id` int DEFAULT NULL,
  PRIMARY KEY (`employee_id`),
  UNIQUE KEY `emp_email_uk` (`email`),
  UNIQUE KEY `emp_emp_id_pk` (`employee_id`),
  KEY `emp_dept_fk` (`department_id`),
  KEY `emp_job_fk` (`job_id`),
  KEY `emp_manager_fk` (`manager_id`),
  CONSTRAINT `emp_dept_fk` FOREIGN KEY (`department_id`) REFERENCES `departments` (`department_id`),
  CONSTRAINT `emp_job_fk` FOREIGN KEY (`job_id`) REFERENCES `jobs` (`job_id`),
  CONSTRAINT `emp_manager_fk` FOREIGN KEY (`manager_id`) REFERENCES `employees` (`employee_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 |
+-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```
使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。
## 4. 修改表
修改表指的是修改数据库中已经存在的数据表的结构。
**使用 ALTER TABLE 语句可以实现：**

- 向已有的表中添加列
- 修改现有表中的列
- 删除现有表中的列
- 重命名现有表中的列
### （1）追加一个列
语法格式如下：
```sql
ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性];
```
举例：
```sql
ALTER TABLE dept80
ADD job_id varchar(15);
```
向名为 dept80 的表中添加一个新的列，这个列的名称是 job_id，数据类型是 varchar，并且这个字符串类型的列可以存储最多15个字符。
### 2) 修改一个列

- 可以修改列的数据类型，长度、默认值和位置
- 修改列的信息有下边这两种方式：

方式一：
```sql
ALTER TABLE 表名 MODIFY 列名 新数据类型 [新属性];
```
举例：
我们来修改一下first_table表的second_column列，把它的数据类型修改为VARCHAR(2)：
```sql
mysql> ALTER TABLE first_table MODIFY second_column VARCHAR(2);
```
方式二：
```sql
ALTER TABLE 表名 CHANGE 旧列名 新列名 新数据类型 [新属性];
```
可以看到这种修改方式需要我们填两个列名，也就是说在修改数据类型和属性的同时也可以修改列名！比如我们修改second_column的列名为second_column1：
```sql
mysql> ALTER TABLE first_table CHANGE second_column second_column1 VARCHAR(2)\G
```

- 修改列排列位置

1.将列设为表的第一列：
```sql
ALTER TABLE 表名 MODIFY 列名 列的类型 列的属性 FIRST;
```
2.将列放到指定列的后边：
```sql
ALTER TABLE 表名 MODIFY 列名 列的类型 列的属性 AFTER 指定列名;
```
比方说我们想把second_column1再放到first_column后边可以这么写：
```sql
mysql> ALTER TABLE first_table MODIFY second_column1 VARCHAR(2) AFTER first_column;
```
### （3）重命名一个列
使用 CHANGE old_column new_column dataType子句重命名列。语法格式如下：
```sql
ALTER TABLE 表名 CHANGE 旧列名 新列名 新数据类型;
```
举例：
```sql
ALTER TABLE dept80
CHANGE department_name dept_name varchar(15);
```
### （4）删除一个列
删除表中某个字段的语法格式如下：
```sql
ALTER TABLE 表名 DROP COLUMN 列名;
```
### （5) 更改表名

- 方式一：使用RENAME
```sql
ALTER TABLE 旧表名 RENAME TO 新表名;
```
我们把first_table表的名称修改为first_table1
```sql
mysql> ALTER TABLE first_table RENAME TO first_table1;
```

- 方式二：
```sql
RENAME TABLE 旧表名1 TO 新表名1, 旧表名2 TO 新表名2, ... 旧表名n TO 新表名n;
```
      这种改名方式的牛逼之处就是它可以在一条语句中修改多个表的名称。这里就不举例了，自己测试一下吧。
如果在修改表名的时候指定了数据库名，还可以将该表转移到对应的数据库下，比方说我们先再创建一个数据库dahaizi：
```sql
mysql> CREATE DATABASE dahaizi;
Query OK, 1 row affected (0.00 sec)

mysql>
```
然后把first_table1表转移到这个dahaizi数据库下：
```sql
mysql> ALTER TABLE first_table1 RENAME TO dahaizi.first_table1;
Query OK, 0 rows affected (0.01 sec)

mysql> SHOW TABLES FROM dahaizi;
+-------------------+
| Tables_in_dahaizi |
+-------------------+
| first_table1      |
+-------------------+
1 row in set (0.00 sec)

mysql> SHOW TABLES FROM xiaohaizi;
+---------------------+
| Tables_in_xiaohaizi |
+---------------------+
| student_info        |
| student_score       |
+---------------------+
2 rows in set (0.00 sec)

mysql>

```
可以看到first_table1就从数据库xiaohaizi转移到dahaizi里边了。我们再用修改表名的方式二再把该表转移到xiaohaizi数据库中，并且将其更名为first_table：
```sql
mysql> RENAME TABLE dahaizi.first_table1 TO xiaohaizi.first_table;
Query OK, 0 rows affected (0.00 sec)

mysql>
```
## 5. 删除表

- 在MySQL中，当一张数据表 没有与其他任何数据表形成关联关系 时，可以将当前数据表直接删除。
- 数据和结构都被删除
- 所有正在运行的相关事务被提交
- 所有相关索引被删除
- 语法格式：
```sql
DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];
```
IF EXISTS 的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存 在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。
举例：
```sql
DROP TABLE dept80;
```

- DROP TABLE 语句不能回滚

分析：在SQL数据库中，回滚（Rollback）是一个事务管理的操作，用于撤销已经执行的事务，使数据库恢复到事务开始之前的状态。回滚通常用于在事务中出现错误或异常情况时撤销操作，确保数据的一致性和完整性。
然而，并非所有的SQL操作都可以通过回滚来撤销。DROP TABLE 语句就是一个不能回滚的操作。这意味着，一旦执行了 DROP TABLE 语句，表及其所有数据、结构、索引、约束等都会被永久删除，无法通过回滚来恢复。
## 6. 清空表

- TRUNCATE TABLE语句： 
   - 删除表中所有的数据
   - 释放表的存储空间
- 举例：
```sql
TRUNCATE TABLE detail_dept;
```

- TRUNCATE语句**不能回滚**，而使用 DELETE 语句删除数据，可以回滚
> 阿里开发规范： 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无 事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。 
> 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。

## 7. 内容扩展
### 拓展1：阿里巴巴《Java开发手册》之MySQL字段命名

- [强制]表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出 现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 
   - 正例：aliyun_admin，rdc_config，level3_name
   - 反例：AliyunAdmin，rdcConfig，level_3_name
- [强制]禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 
- [强制]表必备三字段：id, gmt_create, gmt_modified。 
   - 说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被 动式更新
- [推荐]表的命名最好是遵循 “业务名称_表的作用”。 
   - 正例：alipay_task 、 force_project、 trade_config
- [推荐]库名与应用名称尽量一致。 
-  [参考]合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 
   - 正例：无符号值可以避免误存负数，且扩大了表示范围。

![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718778299888-8b2dc048-67ef-47ac-93d1-a774afbeca0e.png#averageHue=%23f5f5f4&clientId=u21d20c4e-ce74-4&from=paste&height=245&id=u25b67b9c&originHeight=306&originWidth=873&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=87991&status=done&style=none&taskId=uccde88e7-c014-4991-9860-f9bd7438faf&title=&width=698.4)
### 扩展2：操作注意要求

- 表删除 操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信 息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行 备份 ，这样当操作失误时可 以对数据进行恢复，以免造成无法挽回的后果。
- 同样的，在使用 ALTER TABLE 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进 行完整的 备份 ，因为数据库的改变是 无法撤销 的，如果添加了一个不需要的字段，可以将其删除；相 同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。
### 扩展3：MySQL8新特性—DDL的原子化
在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即 DDL操作要么成功要么回滚 。DDL操作回滚日志 写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到） 中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。
分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：
```sql
CREATE DATABASE mytest;
USE mytest;
CREATE TABLE book1(
book_id INT ,
book_name VARCHAR(255)
);
SHOW TABLES;
```
（1）在MySQL 5.7版本中，测试步骤如下： 删除数据表book1和数据表book2，结果如下：
```sql
mysql> DROP TABLE book1,book2;
ERROR 1051 (42S02): Unknown table 'mytest.book2'
```
再次查询数据库中的数据表名称，结果如下：
```sql
mysql> SHOW TABLES;
Empty set (0.00 sec)
```
从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。
（2）在MySQL 8.0版本中，测试步骤如下： 删除数据表book1和数据表book2，结果如下：
```sql
mysql> DROP TABLE book1,book2;
ERROR 1051 (42S02): Unknown table 'mytest.book2'
```
再次查询数据库中的数据表名称，结果如下：
```sql
mysql> show tables;
+------------------+
| Tables_in_mytest |
+------------------+
| book1      |
+------------------+
1 row in set (0.00 sec)
```
从结果可以看出，数据表book1并没有被删除。
# 第九章 数据处理之增删改
## 1. 插入数据
### （1）插入完整的记录
使用这种语法一次只能向表中插入**一条**数据。
**情况1：为表的所有字段按默认顺序插入数据**
```sql
INSERT INTO 表名 VALUES(列1的值，列2的值, ..., 列n的值);
```
比如first_table里有两个列，分别是first_column和second_column，如果我们想要插入完整的记录的话，VAULES()中必须依次填入first_column列和second_column列的值，比如这样：
```sql
mysql> INSERT INTO first_table VALUES(1, 'aaa');
Query OK, 1 row affected (0.00 sec)

mysql>
```
可以看到执行结果是Query OK, 1 row affected (0.01 sec)，表明成功的插入了一行。然后再用SELECT语句看看表中的数据：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | aaa           |
+--------------+---------------+
1 row in set (0.00 sec)

mysql>
```
现在的first_table中就有了一条记录了。在使用这种插入一条完整记录的语法时必须注意，VALUES语句中必须给出表中所有列的值，缺一个都不行，如果我们不知道向某个列填什么值，可以使用填入NULL（前提是该列没有声明NOT NULL属性），就像这样：
```sql
mysql> INSERT INTO first_table VALUES(2, NULL);
Query OK, 1 row affected (0.01 sec)

mysql>

mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | aaa           |
|            2 | NULL          |
+--------------+---------------+
2 rows in set (0.00 sec)

mysql>
```
上述的这种插入方式VALUE列表中参数的顺序与表中各个列的顺序是一一对应的，其实我们也可以在书写插入语句时自定义一下列的顺序，就像这样：
```sql
mysql> INSERT INTO first_table(first_column, second_column) VALUES (3, 'ccc');
Query OK, 1 row affected (0.00 sec)

mysql>
```
在这个语句中，我们显式的指定了列的插入顺序是(first_column, second_column)，对应于VALUES列表中的值的顺序，也就是说first_column与值3对应，second_column与值'ccc'对应。之后即使first_table表中列的结构改变了，这个语句仍然能继续使用。我们也可以随意指定列的插入顺序，比如这样：
```sql
mysql> INSERT INTO first_table(second_column, first_column) VALUES ('ddd', 4);
Query OK, 1 row affected (0.01 sec)

mysql>
```
我们把second_column放在了first_column之前，所以VALUES列表中的值也需要改变顺序，来看一下插入效果：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | aaa           |
|            2 | NULL          |
|            3 | ccc           |
|            4 | ddd           |
+--------------+---------------+
4 rows in set (0.00 sec)

mysql>
```
### （2）插入记录的一部分
我们在插入记录的时候，某些列的值可以被省略，但是这个列必须满足下边列出的某个条件之一：

- 该列允许存储NULL值
- 该列有DEFAULT属性，给出了默认值

我们定义的first_table表中的两个字段都允许存放NULL值，所以在插入数据的时候可以省略部分列的值。在INSERT语句中没有显式指定的列的值将被设置为NULL，比如这样写：
```sql
mysql> INSERT INTO first_table(first_column) VALUES(5);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO first_table(second_column) VALUES('fff');
Query OK, 1 row affected (0.00 sec)

mysql>
```
第一条插入语句我们只指定了first_column列的值是5，而没有指定second_column的值，所以second_column的值就是NULL；第二条插入语句我们只指定了second_column的值是'ddd'，而没有指定first_column的值，所以first_column的值就是NULL，也表示没有数据～ 看一下现在表中的数据：
```
sql

复制代码mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | aaa           |
|            2 | NULL          |
|            3 | ccc           |
|            4 | ddd           |
|            5 | NULL          |
|         NULL | fff           |
+--------------+---------------+
6 rows in set (0.00 sec)

mysql>
```
我们再次强调一下，INSERT语句中指定的列顺序可以改变，但是一定要和VALUES列表中的值一一对应起来。
### （3）批量插入记录
基本语法格式：
```sql
INSERT INTO table_name
VALUES
(value1 [,value2, …, valuen]),
(value1 [,value2, …, valuen]),
……
(value1 [,value2, …, valuen]);
```
或者
```sql
INSERT INTO table_name(column1 [, column2, …, columnn])
VALUES
(value1 [,value2, …, valuen]),
(value1 [,value2, …, valuen]),
……
(value1 [,value2, …, valuen]);
```
每插入一条记录就写一条INSERT语句也不是不行，但是对人来说太烦了，而且每插入一条记录就提交一个请求给服务器远没有一次把所有待插入的记录全部提交给服务器效率高，所以MySQL为我们提供了批量插入的语句，就是直接在VALUES后多加几组值，每组值用小括号()扩起来，各个组之间用逗号分隔就好了，就像这样：
```sql
mysql> INSERT INTO first_table(first_column, second_column) 
->VALUES
->(7, 'ggg'), 
->(8, 'hhh');
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql>
```
我们在这个INSERT语句中插入了(7, 'ggg')、(8, 'hhh')这么两条记录，直接把它们放到VALUES后边用逗号分开就好了，我们看一下插入效果：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | aaa           |
|            2 | NULL          |
|            3 | ccc           |
|            4 | ddd           |
|            5 | NULL          |
|         NULL | fff           |
|            7 | ggg           |
|            8 | hhh           |
+--------------+---------------+
8 rows in set (0.00 sec)

mysql>
```
### （4）将某个查询的结果集插入表中
上边的插入语句都是我们显式的将记录的值放在VALUES后边，其实我们也可以将某个查询的结果集作为数据源插入到表中。基本格式：
```sql
INSERT INTO 目标表名
(tar_column1 [, tar_column2, …, tar_columnn])
SELECT
(src_column1 [, src_column2, …, src_columnn])
FROM 源表名
[WHERE condition]
```
我们先新建一个second_table表：
```sql
mysql> CREATE TABLE second_table (
  ->     s VARCHAR(200),
  ->     i INT
  -> );
Query OK, 0 rows affected (0.03 sec)

mysql>
```
这个表有两个列，一个是VARCHAR类型的s列，另一个是INT类型的i列。现在这个second_table表中是没有数据的，我们想把first_column表中的一些数据插入到second_table表的话可以这么写：
```sql
mysql> INSERT INTO second_table(s, i) 
->SELECT second_column, first_column 
->FROM first_table 
->WHERE first_column < 5;
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql>
```
我们可以把这条INSERT语句分成两部分来理解：

1. 先执行查询语句。
```sql
SELECT second_column, first_column FROM first_table WHERE first_column < 5;
```
这条语句的结果集是
```sql
+---------------+--------------+
| second_column | first_column |
+---------------+--------------+
| aaa           |            1 |
| NULL          |            2 |
| ccc           |            3 |
| ddd           |            4 |
+---------------+--------------+
```

2. 把查询语句得到的结果集插入到指定的表中。

把第1步中的到的结果集中的记录批量插入到second_table表中，得到的结果就是：
```sql
mysql> SELECT * FROM second_table;
+------+------+
| s    | i    |
+------+------+
| aaa  |    1 |
| NULL |    2 |
| ccc  |    3 |
| ddd  |    4 |
+------+------+
4 rows in set (0.00 sec)

mysql>
```
在将某个查询的结果集插入到表中时需要注意，INSERT语句指定的列要和查询列表中的表达式一一对应。比方说上边的INSERT语句指定的列是s, i，对应于查询语句中的second_column, first_column。
### （5）INSERT IGNORE
对于一些是主键或者具有UNIQUE约束的列或者列组合来说，它们不允许重复值的出现，比如我们把first_table的first_column列添加一个UNIQUE约束：
```sql
mysql> ALTER TABLE first_table MODIFY COLUMN first_column INT UNIQUE;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql>
```
因为first_column列有了UNIQUE约束，所以如果待插入记录的first_column列值与已有的值重复的话就会报错，比如这样：
```sql
mysql> INSERT INTO first_table(first_column, second_column) VALUES(1, '哇哈哈');
ERROR 1062 (23000): Duplicate entry '1' for key 'first_column'
mysql>
```
可是这里有一个问题：我们在插入记录之前又不知道表里边有没有主键或者具有UNIQUE约束的列或者列组合重复的记录，所以我们迫切的需要这样的一个功能：对于那些是主键或者具有UNIQUE约束的列或者列组合来说，如果表中已存在的记录中没有与待插入记录在这些列或者列组合上重复的值，那么就把待插入记录插到表中，否则忽略此次插入操作。设计MySQL的大叔给我们提供了INSERT IGNORE的语法来实现这个功能：
```sql
mysql> INSERT IGNORE INTO first_table(first_column, second_column) 
->VALUES(1, '哇哈哈') ;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql>
```
我们只是简单的在INSERT后边加了个IGNORE单词便不再报错了！对于批量插入的情况，INSERT IGNORE同样适用，比如这样：
```sql
mysql> INSERT IGNORE INTO first_table(first_column, second_column) 
->VALUES
->(1, '哇哈哈'), 
->(9, 'iii');
Query OK, 1 row affected, 1 warning (0.00 sec)
Records: 2  Duplicates: 1  Warnings: 1

mysql>
```
这个批量插入的语句中我们想插入(1, '哇哈哈')和(9, 'iii')这两条记录，因为first_column列值为1的记录已经在表中存在，所以这个记录会被忽略，而(9, 'iii')这条记录被插入成功，看插入效果：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | aaa           |
|            2 | NULL          |
|            3 | ccc           |
|            4 | ddd           |
|            5 | NULL          |
|         NULL | fff           |
|            7 | ggg           |
|            8 | hhh           |
|            9 | iii           |
+--------------+---------------+
9 rows in set (0.01 sec)

mysql>
```
### （6）INSERT ON DUPLICATE KEY UPDATE
对于主键或者有唯一性约束的列或列组合来说，新插入的记录如果和表中已存在的记录重复的话，我们可以选择的策略不仅仅是忽略该条记录的插入，也可以选择更新这条重复的旧记录。比如我们想在first_table表中插入一条记录，内容是(1, '哇哈哈')，我们想要的效果是：对于那些是主键或者具有UNIQUE约束的列或者列组合来说，如果表中已存在的记录中没有与待插入记录在这些列或者列组合上重复的值，那么就把待插入记录插到表中，否则按照规定去更新那条重复的记录中某些列的值。设计MySQL的大叔给我们提供了INSERT ... ON DUPLICATE KEY UPDATE ...的语法来实现这个功能：
```sql
mysql> INSERT INTO first_table (first_column, second_column) 
->VALUES(1, '哇哈哈') ON DUPLICATE KEY UPDATE second_column = '雪碧';
Query OK, 2 rows affected (0.00 sec)

mysql>
```
这个语句的意思就是，对于要插入的数据(1, '哇哈哈')来说，如果first_table表中已经存在first_column的列值为1的记录（因为first_column列具有UNIQUE约束），那么就把该记录的second_column列更新为'雪碧'，看一下效果：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | 雪碧          |
|            2 | NULL          |
|            3 | ccc           |
|            4 | ddd           |
|            5 | NULL          |
|         NULL | fff           |
|            7 | ggg           |
|            8 | hhh           |
|            9 | iii           |
+--------------+---------------+
9 rows in set (0.00 sec)

mysql>
```
对于那些是主键或者具有UNIQUE约束的列或者列组合来说，如果表中已存在的记录中有与待插入记录在这些列或者列组合上重复的值，我们可以使用VALUES(列名)的形式来引用待插入记录中对应列的值，比方说下边这个INSERT语句：
```sql
mysql> INSERT INTO first_table (first_column, second_column) 
->VALUES(1, '哇哈哈') ON DUPLICATE KEY UPDATE second_column = VALUES(second_column);
Query OK, 2 rows affected (0.00 sec)

mysql>
```
其中的VALUES(second_column)就代表着待插入记录中second_column的值，本例中就是'哇哈哈'。有的同学就呵呵了，我直接写成下边这种形式不好么：
```sql
INSERT INTO first_table (first_column, second_column) 
VALUES(1, '哇哈哈') ON DUPLICATE KEY UPDATE second_column = '哇哈哈';
```
是的，没有任何问题，但是在批量插入大量记录的时候该咋办呢？此时VALUES(second_column)就 派上了大用场：
```sql
mysql> INSERT INTO first_table (first_column, second_column) 
->VALUES(2, '红牛'), 
->(3, '橙汁儿') 
->ON DUPLICATE KEY UPDATE second_column = VALUES(second_column);
Query OK, 4 rows affected (0.00 sec)
Records: 2  Duplicates: 2  Warnings: 0

mysql>
```
我们准备批量插入两条记录(2, '红牛')和(3, '橙汁儿')，在遇到重复记录时把该重复记录的second_column列更新成待插入记录中second_column列的值就好了，所以效果是这样：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | 哇哈哈        |
|            2 | 红牛          |
|            3 | 橙汁儿        |
|            4 | ddd           |
|            5 | NULL          |
|         NULL | fff           |
|            7 | ggg           |
|            8 | hhh           |
|            9 | iii           |
+--------------+---------------+
9 rows in set (0.00 sec)

mysql>
```
## 2. 更新数据

- 使用 UPDATE 语句更新数据。语法如下：
```sql
UPDATE 表名 SET 列1=值1, 列2=值2, ...,  列n=值n [WHERE 布尔表达式];
```

-  可以一次更新**多条**数据。 
-  如果需要回滚数据，需要保证在DML前，进行设置：**SET AUTOCOMMIT = FALSE; **
- 我们在UPDATE单词后边指定要更新的表，然后把你想更新的列的名称和该列更新后的值写到SET单词后边，如果想更新多个列的话，它们之间用逗号,分隔开。如果我们不指定WHERE子句，那么表中所有的记录都会被更新，否则的话只有符合WHERE子句中的条件的记录才可以被更新。
-  使用 **WHERE** 子句指定需要更新的数据。 

把first_table表中first_column的值是NULL的记录的first_column的值更新为5，second_column的值更新为'乳娃娃'，可以这么写：
```sql
mysql> UPDATE first_table 
->SET first_column = 5, second_column = '乳娃娃' 
->WHERE first_column IS NULL;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql>

```
Query OK, 1 row affected (0.01 sec)就表明成功更新了1行数据。Rows matched: 1表示符合WHERE条件的记录一共有1条，Changed: 1表示有1条记录的内容发生了变化。我们看一下修改后的效果：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | 哇哈哈        |
|            2 | 红牛          |
|            3 | 橙汁儿        |
|            5 | 乳娃娃        |
+--------------+---------------+
4 rows in set (0.00 sec)

mysql>
```
这里再次强调一下：虽然更新语句的WHERE子句是可选的，但是如果不加WHERE子句的话将更新表中所有的记录，这是玩火的行为！超级危险！十分危险！请慎重使用。
另外，我们也可以使用LIMIT子句来限制想要更新的记录数量，使用ORDER BY子句来指定符合条件的记录的更新顺序，比方说这样：
```sql
mysql> UPDATE first_table 
->SET second_column='爽歪歪' 
->ORDER BY first_column DESC 
->LIMIT 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql>
```
**详细分析：**

1. **UPDATE first_table**： 这是一个 UPDATE 语句，用于更新表 first_table 中的记录。first_table 是你要更新的表的名称。
2. **SET second_column='爽歪歪'**： 这部分指定了要更新的列和新值。在这个例子中，将 second_column 列的值设置为 '爽歪歪'。即，second_column 列的值将被更改为 '爽歪歪'。
3. **ORDER BY first_column DESC**： 这部分指定了更新操作的排序规则。ORDER BY 子句用于对记录进行排序。在这里，first_column 列用于排序，并且 DESC 表示按降序排序。也就是说，first_column 列中最大的值会排在最前面。
4. **LIMIT 1**： 这部分指定了更新操作只应用于排序后的第一行。LIMIT 1 表示只更新一条记录。

这段代码的作用是：

- 在 first_table 表中，找到 first_column 列值最大的那一行（因为是降序 DESC 排序）。
- 将该行的 second_column 列的值更新为 '爽歪歪'。
- 最终，只会有一行记录受到影响，因为使用了 LIMIT 1 限制。

上述语句就是想删更新first_column列值最大的那条记录，我们看一下更新后的效果：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | 哇哈哈        |
|            2 | 红牛          |
|            3 | 橙汁儿        |
|            5 | 爽歪歪        |
+--------------+---------------+
4 rows in set (0.00 sec)

mysql>
```
可以看到first_column列值最大的那条记录，也就是first_column列值为5的那条记录的second_column列的值已经被更新为'爽歪歪'了。
## 3. 删除数据
如果某些记录我们不想要了，那可以使用下边的语句把它们给删除掉：
```sql
DELETE FROM 表名 [WHERE 表达式];
```
我们把first_table中first_column的值大于4的记录都删掉看看：
```sql
mysql> DELETE FROM first_table WHERE first_column > 4;
Query OK, 4 rows affected (0.00 sec)

mysql>
```
其中的Query OK, 4 rows affected (0.00 sec)表明成功的删除了4条记录，然后看一下删除效果：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | 哇哈哈        |
|            2 | 红牛          |
|            3 | 橙汁儿        |
|            4 | ddd           |
|         NULL | fff           |
+--------------+---------------+
5 rows in set (0.00 sec)

mysql>
```
first_table表中first_column列大于4的记录就都不见了哈～ 当然删除语句的WHERE子句是可选的，如果不加WHERE子句的话，意味着删除表中所有数据，比如我们想清除second_table表中的所有数据，可以这么写：
```sql
mysql> DELETE FROM second_table;
Query OK, 4 rows affected (0.01 sec)

mysql>
```
不过在使用删除语句需要特别特别注意：虽然删除语句的WHERE条件是可选的，但是如果不加WHERE条件的话将删除所有的记录，这是玩火的行为！超级危险！十分危险！请慎重使用。
另外，我们也可以使用LIMIT子句来限制想要删除掉的记录数量，使用ORDER BY子句来指定符合条件的记录的删除顺序，比方说这样：
```sql
mysql> DELETE FROM first_table 
->ORDER BY first_column DESC 
->LIMIT 1;
Query OK, 1 row affected (0.00 sec)

mysql>
```
上述语句就是想删除掉first_column列值最大的那条记录，我们看一下删除后的效果：
```sql
mysql> SELECT * FROM first_table;
+--------------+---------------+
| first_column | second_column |
+--------------+---------------+
|            1 | 哇哈哈        |
|            2 | 红牛          |
|            3 | 橙汁儿        |
|         NULL | fff           |
+--------------+---------------+
4 rows in set (0.00 sec)

mysql>
```
可以看到first_column列值最大的那条记录，也就是first_column列值为4的那条记录已经被删除掉了。
## 4. MySQL8新特性：计算列
什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列 不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。
在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。
举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的 值。 首先创建测试表tb1，语句如下：
```sql
CREATE TABLE tb1(
  id INT,
  a INT,
  b INT,
  c INT GENERATED ALWAYS AS (a + b) VIRTUAL
);
```
# 第十章 MySQL数据类型精讲
## 1. MySQL中的数据类型
![](https://cdn.nlark.com/yuque/0/2024/png/33643071/1708438502394-7cb5c028-3ee0-4416-875c-30318346cd0b.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_937%2Climit_0#averageHue=%23fcfcfc&from=url&id=MRj47&originHeight=808&originWidth=937&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)

| **类型** | **举例** |
| --- | --- |
| 整数类型 | TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT |
| 浮点类型 | FLOAT、DOUBLE |
| 定点数类型 | DECIMAL |
| 位类型 | BIT |
| 日期时间类型 | YEAR、TIME、DATE、DATETIME、TIMESTAMP |
| 文本字符串类型 | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT |
| 枚举类型 | ENUM |
| 集合类型 | SET |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB |
| JSON类型 | JSON对象、JSON数组 |
| 空间数据类型 | 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON； 集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION |

**常见数据类型的属性，如下：**

| **MySQL关键字** | **含义** |
| --- | --- |
| NULL | TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT |
| NOT NULL | FLOAT、DOUBLE |
| DEFAULT | DECIMAL |
| PRIMARY KEY | BIT |
| AUTO_INCREMENT | YEAR、TIME、DATE、DATETIME、TIMESTAMP |
| UNSIGNED | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT |
| CHARACTER SET name | ENUM |

## 2. 整数类型
### （1) 类型介绍
整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。
它们的区别如下表所示：

| 类型 | 占用的存储空间 | 无符号数取值范围 | 有符号数取值范围 | 含义 |
| --- | --- | --- | --- | --- |
| TINYINT | 1字节 | 0 ~ 2⁸-1 | -2⁷ ~ 2⁷-1 | 非常小的整数 |
| SMALLINT | 2字节 | 0 ~ 2¹⁶-1 | -2¹⁵ ~ 2¹⁵-1 | 小的整数 |
| MEDIUMINT | 3字节 | 0 ~ 2²⁴-1 | -2²³ ~ 2²³-1 | 中等大小的整数 |
| INT（别名：INTEGER） | 4字节 | 0 ~ 2³²-1 | -2³¹ ~ 2³¹-1 | 标准的整数 |
| BIGINT | 8字节 | 0 ~ 2⁶⁴-1 | -2⁶³ ~ 2⁶³-1 | 大整数 |

### （2) 可选属性
**整数类型的可选属性有三个：**

- **M**

M : 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用 字符填满宽度。该项功能需要配合“ ZEROFILL ”使用，表示用“0”填满宽度，否则指定显示宽度无效。 
如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？
答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即 显示宽度与类型可以存储的 值范围无关 。**从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性**。 
整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认 的宽度值。
举例：
```sql
CREATE TABLE test_int1 ( x TINYINT, y SMALLINT, z MEDIUMINT, m INT, n BIGINT );
```
查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718784592874-5498b08c-6b20-49a4-ac8a-8aff8bc7785c.png#averageHue=%23f6f6f6&clientId=uf51d38bb-17f7-4&from=paste&height=255&id=u546b314b&originHeight=319&originWidth=925&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=39029&status=done&style=none&taskId=u01fa10b9-6f78-4cd9-985a-6941e341361&title=&width=740)
TINYINT有符号数和无符号数的取值范围分别为-128~127和0~255，由于负号占了一个数字位，因此 TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。

- UNSIGNED

UNSIGNED : 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无 符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设 置为无符号类型。 int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718784749907-a8efdebe-226b-4241-a76f-e84b3dd25de9.png#averageHue=%23f7f7f7&clientId=uf51d38bb-17f7-4&from=paste&height=262&id=u23f1eedc&originHeight=327&originWidth=939&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31683&status=done&style=none&taskId=u46da8c71-390f-4641-baa9-4f86b71aa3e&title=&width=751.2)

- ZEROFILL

ZEROFILL : 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指 定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。
原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都 是占用 4 bytes 的存储空间(对这句话的分析在下面)。也就是说，**int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。**如果整 数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。
> 原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都 是占用 4 bytes 的存储空间。
> 分析：在MySQL中，INT(M)中的M表示的是显示宽度，不是存储空间的大小。INT(M)的存储空间始终是固定的，占用4个字节（32位），无论M的值是多少。M的值只影响在显示时的格式，而不影响实际存储的数值。

### （3) 适用场景
TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。
SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。
MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等。
INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。
BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证 券公司衍生产品持仓等。
### （4) 如何选择？
在评估用哪种整数类型的时候，你需要考虑 存储空间 和 可靠性 的平衡问题：一方 面，用占用字节数少 的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一 旦遇到超出取值范围的情况，就可能引起 系统错误 ，影响可靠性。
举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每 天都有旧商品下架，新商品上架，这样不断迭代，日积月累。
如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。
你要注意的是，在实际工作中，**系统故障产生的成本远远超过增加几个字段存储空间所产生的成本**。因 此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。
## 3. 浮点类型
### （1) 类型介绍
浮点数和定点数类型的特点是可以 处理小数 ，你可以把整数看成小数的一个特例。因此，浮点数和定点 数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。

-  FLOAT 表示单精度浮点数； 
-  DOUBLE 表示双精度浮点数； 
| 类型 | 占用的存储空间（单位：字节） | 绝对值最小非0值 | 绝对值最大非0值 | 含义 |
| --- | --- | --- | --- | --- |
| FLOAT | 4 | ±1.175494351E-38 | ±3.402823466E+38 | 单精度浮点数 |
| DOUBLE | 8 | ±2.2250738585072014E-308 | ±1.7976931348623157E+308 | 双精度浮点数 |

![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718786318272-c0a908f4-2b40-4c41-8669-8829c8b04117.png#averageHue=%23d4d4d4&clientId=u054ab04a-7797-4&from=paste&height=246&id=ub978bb93&originHeight=307&originWidth=918&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=116162&status=done&style=none&taskId=uc6f858d0-43d4-4712-8db6-ed645cf7e09&title=&width=734.4)

-  REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”，那 么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现： 
```sql
SET sql_mode = “REAL_AS_FLOAT”;
```
以单精度浮点数类型FLOAT类型为例，它占用的4个字节的各个组成部分如下图所示：
![](https://cdn.nlark.com/yuque/0/2024/webp/33643071/1718785986426-deaa569b-38d4-48a7-a437-ee17dfc8d41c.webp#averageHue=%23fcfbfa&clientId=u054ab04a-7797-4&from=paste&id=u65b90635&originHeight=522&originWidth=984&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u97e54d89-cce4-4f80-b08f-8c11dabc2f5&title=)
另外需要注意的是，虽然有的十进制小数，比如1.875可以被很容易的转换成二进制数1.111，但是更多的小数是无法直接转换成二进制的，比如说0.3，它转换成的二进制小数就是一个无限小数，但是我们现在只能用4个字节或者8个字节来表示这个小数，所以只能进行一些舍入来近似的表示，所以我们说计算机的浮点数表示有时是不精确的。
**问题：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于 有符号数取值范围大于等于零的部分呢？**
MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) 。因此，无论有没有符号，MySQL 的浮 点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于 零的部分。
### （2) 数据精度说明
对于浮点类型，在MySQL中单精度值使用 4 个字节，双精度值使用 8 个字节。

-  MySQL允许使用 非标准语法 （其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么 用）： FLOAT(M,D) 或 DOUBLE(M,D) 。这里，M称为 精度 ，D称为 标度 。(M,D)中 M=整数位+小数 位，D=小数位。 D<=M<=255，0<=D<=30。
对于我们用户而言，使用的都是十进制小数。如果我们事先知道表中的某个列要存储的小数在一定范围内，我们可以使用FLOAT(M, D)或者DOUBLE(M, D)来限制可以存储到本列中的小数范围。其中：
   - M表示该小数最多需要的十进制有效数字个数。

注意是有效数字个数，比方说对于小数-2.3来说有效数字个数就是2，对于小数0.9来说有效数字个数就是1。

   - D表示该小数的小数点后的十进制数字个数。

这个好理解，小数点后有几个十进制数字，D的值就是什么。
举个例子看一下，设置了M和D的单精度浮点数的取值范围的变化：

| 类型 | 取值范围 |
| --- | --- |
| FLOAT(4, 1) | -999.9~999.9 |
| FLOAT(5, 1) | -9999.9~9999.9 |
| FLOAT(6, 1) | -99999.9~99999.9 |
| FLOAT(4, 0) | -9999~9999 |
| FLOAT(4, 1) | -999.9~999.9 |
| FLOAT(4, 2) | -99.99~99.99 |

可以看到，在D相同的情况下，M越大，该类型的取值范围越大；在M相同的情况下，D越大，该类型的取值范围越小。当然，M和D的取值也不是无限大的，M的取值范围是1~255，D的取值范围是0~30，而且D的值必须不大于M。M和D都是可选的，如果我们省略了它们，那它们的值按照机器支持的最大值来存储。

-  FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示。 
-  说明：浮点类型，也可以加 UNSIGNED ，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然 只能表示0-9.99的范围。 
-  不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下： 
   - 如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值
   - 如果存储时，小数点部分若超出范围，就分以下情况： 
      - 若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余 的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。
      - 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入 999.995和-999.995都会报错。
-  **从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用**，将来可 能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。 
### （3) 精度误差说明
浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我 们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 = 1.1。而使用sum之后查询：
```sql
CREATE TABLE test_double2(
  f1 DOUBLE
);
INSERT INTO test_double2
VALUES(0.47),(0.44),(0.19);
```
```sql
mysql> SELECT SUM(f1)
-> FROM test_double2;
+--------------------+
| SUM(f1) |
+--------------------+
| 1.0999999999999999 |
+--------------------+
1 row in set (0.00 sec)
```
查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型 改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。
那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。
MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二 进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如 果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范 围内进行四舍五入。
在编程中，如果用到浮点数，要特别注意误差问题，**因为浮点数是不准确的，所以我们要避免使用“=”来 判断两个数是否相等。**同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数 类型： DECIMAL 。
## 4. 定点数类型
### （1) 类型介绍

- MySQL中的定点数类型只有 DECIMAL 一种类型。
| 类型 | 占用的存储空间（单位：字节） | 有符号数取值范围 |
| --- | --- | --- |
| DECIMAL(M,D),DEC,NUMERIC | 取决于M和D(M+2) | 有效范围由M和D决定 |

使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0<=M<=65， 0<=D<=30，D<M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。
此处的M和D的含义与浮点数中的含义一样。M和D对取值范围的影响我们之前在唠叨浮点数的时候已经介绍过了，但是我们又说单精度浮点数类型FLOAT(M, D)占用的字节数一直都是4字节，双精度浮点数DOUBLE(M, D)占用的字节数一直都是8字节，它们占用的存储空间大小并不随着M和D的值的变动而变动，为啥到了这个所谓的定点数类型DECIMAL(M, D)中，它占用的存储空间大小就和M、D的取值有关了呢？哈哈，回答这个问题还得且听我细细道来。
我们说定点数是一种精确的小数，为了达到精确的目的我们就不能把它转换成二进制小数之后再存储(因为有很多十进制小数转为二进制小数后需要进行舍入操作，导致二进制小数表示的数值是不精确的)。其实转念一想，所谓的小数只是把两个十进制整数用小数点分割开来而已，我们只要把小数点左右的两个十进制整数给存储起来，那不就是精确的了么。比方说对于十进制小数2.38来说，我们可以把这个小数的小数点左右的两个整数，也就是2和38分别保存起来，那么不就相当于保存了一个精确的小数么，这波操作是不是很6。
当然事情并没有这么简单，对于给定M、D值的DECIMAL(M, D)类型，比如DEMCIMAL(16, 4)来说：

- 首先确定小数点左边的整数最多需要存储的十进制位数是12位，小数点右边的整数需要存储的十进制位数是4位，如图所示：

![](https://cdn.nlark.com/yuque/0/2024/webp/33643071/1718787319981-d22b970d-d4e1-4db7-85c1-a6c05be981ea.webp#averageHue=%23fcf9f7&clientId=u054ab04a-7797-4&from=paste&id=uab17cb26&originHeight=507&originWidth=785&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ueaf2ebf3-53d6-4844-8159-87a58689bbd&title=)

- 从小数点位置出发，每个整数每隔9个十进制位划分为1组，效果就是这样：

![](https://cdn.nlark.com/yuque/0/2024/webp/33643071/1718787319989-c023af6f-e6ad-46f1-a210-2e2105f2d632.webp#averageHue=%23f7f2ef&clientId=u054ab04a-7797-4&from=paste&id=ueb0fdae7&originHeight=402&originWidth=1397&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud8acf925-63b3-4cdc-962f-660d868617c&title=)
从图中可以看出，如果不足9个十进制位，也会被划分成一组。

- 针对每个组中的十进制数字，将其转换为二进制数字进行存储，根据组中包含的十进制数字位数不同，所需的存储空间大小也不同，具体见下表：
| 组中包含的十进制位数 | 占用存储空间大小（单位：字节） |
| --- | --- |
| 1或2 | 1 |
| 3或4 | 2 |
| 5或6 | 3 |
| 7或8或9 | 4 |

所以DECIMAL(16, 4)共需要占用8个字节的存储空间大小，这8个字节由下边3个部分组成：

   - 第1组包含3个十进制位，需要使用2个字节存储。
   - 第2组包含9个十进制位，需要使用4个字节存储。
   - 第3组包含4个十进制位，需要使用2个字节存储。
- 将转换完成的比特位序列的最高位设置为1。

这些步骤看的有一丢丢懵逼吧，别着急，举个例子就都清楚了。比方说我们使用定点数类型DECIMAL(16, 4)来存储十进制小数1234567890.1234，这个小数会被划分成3个部分：
```sql
1 234567890 1234
```
也就是：

- 第1组中包含整数1。
- 第2组中包含整数234567890。
- 第3组中包含整数1234。

然后将每一组中的十进制数字转换成对应的二进制数字：

- 第1组占用2个字节，整数1对应的二进制数就是（字节之间实际上没有空格，只不过为了大家理解上的方便我们加了一个空格）：
```sql
00000000 00000001
```
二进制看起来太难受，我们还是转换成对应的十六进制看一下：
```sql
0x0001
```

- 第2组占用4个字节，整数234567890对应的十六进制数就是：
```sql
0x0DFB38D2
```

- 第3组占用2个字节，整数1234对应的十六进制数就是：
```sql
0x04D2
```
所以将这些十六进制数字连起来之后就是：
```sql
0x00010DFB38D204D2
```
最后还要将这个结果的最高位设置为1，所以最终十进制小数1234567890.1234使用定点数类型DECIMAL(16, 4)存储时共占用8个字节，具体内容为：
```sql
0x80010DFB38D204D2
```
![714a324f740f698ef9710adf42d65517.jpg](https://cdn.nlark.com/yuque/0/2024/jpeg/33643071/1718787931468-2314a6a6-41af-41bf-9683-ad290ae414c8.jpeg#averageHue=%23fbf3eb&clientId=u054ab04a-7797-4&from=paste&height=259&id=ud2afc8ab&originHeight=583&originWidth=642&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=177035&status=done&style=none&taskId=u1d744d9f-9a8e-4dd5-a2de-fbdcbc0d9d1&title=&width=285.60003662109375)
有的同学会问，如果我们想使用定点数类型DECIMAL(16, 4)存储一个负数怎么办，比方说-1234567890.1234，这时只需要将0x80010DFB38D204D2中的每一个比特位都执行一个取反操作就好，也就是得到下边这个结果：
```sql
0x7FFEF204C72DFB2D
```
从上边的叙述中我们可以知道，对于DECIMAL(M, D)类型来说，给定的M和D的值不同，所需的存储空间大小也不同。可以看到，与浮点数相比，定点数需要更多的空间来存储数据，所以如果不是在某些需要存储精确小数的场景下，一般的小数用浮点数表示就足够了。
对于定点数类型DECIMAL(M, D)来说，M和D都是可选的，默认的M的值是10，默认的D的值是0，也就是说下列等式是成立的：
```sql
 DECIMAL = DECIMAL(10) = DECIMAL(10, 0)
DECIMAL(n) = DECIMAL(n, 0)
```
另外M的范围是1~65，D的范围是0~30，且D的值不能超过M。

- 定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的。
- 当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的 精度范围时，则MySQL同样会进行四舍五入处理。
- **浮点数 vs 定点数 **
   - 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用 于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动 力学等）
   - 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉 及金额计算的场景）
### （2) 开发中的经验
> “由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型 外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能 差。 ” ——来自某项目经理

## 5. 位类型：BIT
BIT类型中存储的是二进制值，类似010110。

| 二进制字符串类型 | 长度 | 长度范围 | 占用空间 |
| --- | --- | --- | --- |
| BIT(M) | M | 1 <= M <= 64 | 约为(M + 7)/8个字节 |

其中M的取值范围为1~64，而且M可以省略，它的默认值为1，也就是说BIT(1)和BIT的意思是一样的。
MySQL是以字节为单位存储数据的，一个字节拥有8个比特位。如果我们想存储的比特位个数不足整数个字节，那么MySQL会偷偷的填充满，比方说：

- BIT(1)类型仅仅需要存储1个比特位的数据，但是MySQL会为其申请(1+7)/8 = 1个字节。
- BIT(5)类型仅仅需要存储5个比特位的数据，但是MySQL会为其申请(5+7)/8 = 1个字节。
- BIT(9)类型仅仅需要存储9个比特位的数据，但是MySQL会为其申请(9+7)/8 = 2个字节。
## 6. 日期与时间类型
日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的 时间标签，从而进行数据查询、统计和处理。
MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间 类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。

- YEAR 类型通常用来表示年
- DATE 类型通常用来表示年、月、日
- TIME 类型通常用来表示时、分、秒
- DATETIME 类型通常用来表示年、月、日、时、分、秒
- TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒
| 类型 | 名称 | 字节 | 日期格式 | 最小值 | 最大值 |
| --- | --- | --- | --- | --- | --- |
| YEAR | 年 | 1 | YYYY或YY | 1901 | 2155 |
| TIME | 时间 | 3 | HH:MM:SS | -838:59:59 | 838:59:59 |
| DATE | 日期 | 3 | YYYY-MM-DD | 1000-01-01 | 9999-12-03 |
| DATETIME | 日期时间 | 8 | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 | 9999-12-31 23:59:59 |
| TIMESTAMP | 日期时间 | 4 | YYYY-MM-DD HH:MM:SS | 1970-01-01 00:00:00 UTC | 2038-01-19 03:14:07UTC |

可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据 实际需要灵活选取。
为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表 示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。
### （1）YEAR类型
YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 1个字节 的存储空间。
在MySQL中，YEAR有以下几种存储格式：

- 以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。
- 以2位字符串格式表示YEAR类型，最小值为00，最大值为99。
   - 当取值为01到69时，表示2001到2069；
   - 当取值为70到99时，表示1970到1999；
   - 当取值整数的0或00添加的话，那么是0000年；
   - 当取值是日期/字符串的'0'添加的话，是2000年。

**从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用。**YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。
### （2）DATE类型
DATE类型表示日期，没有时间部分，格式为 YYYY-MM-DD ，其中，YYYY表示年份，MM表示月份，DD表示日期。需要 3个字节 的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。

- 以 YYYY-MM-DD 格式或者 YYYYMMDD 格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。
- 以 YY-MM-DD 格式或者 YYMMDD 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。
- 使用 CURRENT_DATE() 或者 NOW() 函数，会插入当前系统的日期。
### （3）TIME类型
TIME类型用来表示时间，不包含日期部分。在MySQL中，需要 3个字节 的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。
在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。
（1）可以使用带有冒号的字符串，比如' D HH:MM:SS' 、' HH:MM:SS '、' HH:MM '、' D HH:MM '、' D HH '或' SS '格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。 
（2）可以使用不带有冒号的字符串或者数字，格式为' HHMMSS '或者 HHMMSS 。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。 
（3）使用 CURRENT_TIME() 或者 NOW() ，会插入当前系统的时间。
### （4）DATETIME类型
DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 8 个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为 YYYY-MM-DD HH:MM:SS ，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。
在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。

- 以 YYYY-MM-DD HH:MM:SS 格式或者 YYYYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。
   - 以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。
   - 以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。
- 使用函数 CURRENT_TIMESTAMP() 和 NOW() ，可以向DATETIME类型的字段插入系统的当前日期和

时间。
### （5）TIMESTAMP类型
TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是 YYYY-MM-DD HH:MM:SS ，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。

- **存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。**

向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。
如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。
**TIMESTAMP和DATETIME的区别：**

- TIMESTAMP存储空间比较小，表示的日期时间范围也比较小
- 底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。
- 两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。
- TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。
### （6）开发中经验
用得最多的日期时间类型，就是 DATETIME 。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。
此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用 时间戳 ，因为DATETIME虽然直观，但不便于计算。
## 7. 文本字符串类型
MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、LONGTEXT 、 ENUM 、 SET 等类型。

| 类型 | 最大长度 | 存储空间要求 | 含义 |
| --- | --- | --- | --- |
| CHAR(M) | M个字符 | M×W个字节 | 固定长度的字符串 |
| VARCHAR(M) | M个字符 | L+1 或 L+2 个字节 | 可变长度的字符串 |
| TINYTEXT | 2⁸-1 个字节 | L+1个字节 | 非常小型的字符串 |
| TEXT | 2¹⁶-1 个字节 | L+2 个字节 | 小型的字符串 |
| MEDIUMTEXT | 2²⁴-1 个字节 | L+3个字节 | 中等大小的字符串 |
| LONGTEXT | 2³²-1 个字节 | L+4个字节 | 大型的字符串 |

### （1）CHAR与VARCHAR类型
CHAR和VARCHAR类型都可以存储比较短的字符串。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718791583407-5eb6c36e-d2d8-40e8-b1d6-6729116059e7.png#averageHue=%23f9f9f9&clientId=u3e5a2ee4-0606-4&from=paste&height=114&id=ude801616&originHeight=161&originWidth=922&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35329&status=done&style=none&taskId=u236493f2-1c3f-4ebf-b0f3-33aa69849b6&title=&width=653.6000366210938)
**CHAR类型：**

- CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。
- 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 右侧填充 空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。
- 定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。

**VARCHAR类型：**

- VARCHAR(M) 定义时， 必须指定 长度M，否则报错。
- MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20**字符。**
- 检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。

如果你表中的某个列需要存储字符串类型的数据，而且这些字符串长短不一，那么使用CHAR(M)可能会浪费很多存储空间，VARCHAR(M)正是为了解决这个问题而生的。
VARCHAR(M)中的M也是代表该类型最多可以存储的字符数量，理论上的取值范围是1~65535。但是MySQL中还有一个规定，表中某一行包含的所有列中存储的数据大小总共不得超过65535个字节（注意是字节），也就是说VARCHAR(M)类型实际能够容纳的字符数量是小于65535的。
VARCHAR(M)类型占用的存储空间不确定，那系统在读一个VARCHAR(M)类型的数据时怎么知道该数据占用多少个字节呢？答案是：不知道。所以一个VARCHAR(M)类型表示的数据其实是由这么两部分组成：

1. 真正的字符串内容。

假设真正的字符串在特定字符集编码后占用的字节数为L。

2. 占用字节数。

假设VARCHAR(M)类型采用的字符集编码一个字符最多需要W个字节，那么：

   - 当M×W < 256时，只需要一个字节来表示占用的字节数。
   - 当M×W >= 256且M×W < 65536时，需要两个字节来表示占用的字节数。

小贴士：

一个字节占用8个比特位，能表示的最大无符号数就是255，两个字节占用16个比特位，能表示的最大无符号数就是65535。
我们还用学生的姓名属性做例子，假设我们给姓名列定义的类型为采用utf8字符集的VARCHAR(5)，也就是说M = 5、W = 3，所以M × W= 5×3 = 15，而15 < 256，所以我们只需要一个字节来表示真实数据占用的字节长度就好了。对于'杜子腾'和'范统'这两个字符串来说，它们在utf8字符集下可以被编码成如下的样子(二进制太长了，用16进制表示)：
```
arduino

复制代码'杜子腾'：0xE69D9CE5AD90E885BE （共9个字节）
'范统'：0xE88C83E7BB9F （共6个字节）
```
那么这两个字符串的实际存储示意图就是这样：
![](https://cdn.nlark.com/yuque/0/2024/webp/33643071/1718792201812-b5f0203f-d712-4d28-b8d6-b4e0975dd2cc.webp#averageHue=%23e3eddd&clientId=u3e5a2ee4-0606-4&from=paste&id=u170b2047&originHeight=495&originWidth=1155&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u57a556da-4c9c-4ef0-b14f-ce277dedc88&title=)
而如果我们给姓名列定义的类型为采用utf8字符集的VARCHAR(100)，也就是说M = 100、W = 3，所以M × W= 100×3 = 300，而300 > 256，所以我们需要2个字节来表示真实数据占用的字节长度，此时'杜子腾'和'范统'这两个字符串的实际存储示意图就是这样：
![](https://cdn.nlark.com/yuque/0/2024/webp/33643071/1718792201807-a7d90762-c83f-47e4-bbd4-8af33b96e0cb.webp#averageHue=%23e3eedd&clientId=u3e5a2ee4-0606-4&from=paste&id=u071a1e0f&originHeight=512&originWidth=1149&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud97515e5-27e0-42c2-9151-aa2a0f214f4&title=)
从上边的示例中可以看出，VARCHAR(M)类型占用的存储空间大小随着实际存储的内容变化而变化，假设实际存储的内容占用的字节长度为L，那么整个VARCHAR(M)类型占用的存储空间大小就是L+1或者L+2个字节。所以我们说**VARCHAR(M)**是一种可变长度的字符串类型。
**哪些情况使用 CHAR 或 VARCHAR 更好**

| 类型 | 特点 | 空间上 | 时间上 | 适用场景 |
| --- | --- | --- | --- | --- |
| CHAR(M) | 固定长度 | 浪费存储空间 | 效率高 | 存储不大，速度要求高 |
| VARCHAR(M) | 可变长度 | 节省存储空间 | 效率低 | 非CHAR的情况 |

情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。
情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。
情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。
情况4：具体存储引擎中的情况：

- MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。
- MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。
- InnoDB 存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且**主要影响性能的因素是数据行使用的存储总量**，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。
### （2）TEXT类型
在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。
在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。
每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：

| 文本字符类型 | 特点 | 长度 | 长度范围 | 占用的存储空间 |
| --- | --- | --- | --- | --- |
| TINYTEXT | 小文本、可变长度 | L | 0 <= L <= 255  | L + 2 个字节 |
| TEXT | 文本、可变长度 | L | 0 <= L <= 65535 | L + 2 个字节 |
| MEDIUMTEXT | 中等文本、可变长度 | L | 0 <= L <= 16777215  | L + 3 个字节 |
| LONGTEXT | 大文本、可变长度 | L | 0 <= L <= 4294967295(相当于4GB)  | L + 4 个字节 |

**由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键。**遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M)。
**开发中经验：**
TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表
## 8. ENUM类型
ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。
其所需要的存储空间由定义ENUM类型时指定的成员个数决定。

| 文本字符串类型 | 长度 | 长度范围 | 占用的存储空间 |
| --- | --- | --- | --- |
| ENUM | L | 1 <= L <= 65535 | 1或2个字节 |

- 当ENUM类型包含1～255个成员时，需要1个字节的存储空间；
- 当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。
- ENUM类型的成员个数的上限为65535个。

视角回到我们的学生信息表，性别一列也需要填写字符串，但是比较特殊的一点是，这一列只能填男或者女，填别的字符串就尴尬了！针对这种情况，我们提出了一个叫ENUM的类型，也称为枚举类型，它的格式如下：
```sql
ENUM('str1', 'str2', 'str3' ⋯)
```
它表示在给定的字符串列表里选择一个。比如我们的性别一列可以定义成ENUM('男', '女')类型。这个的意思就是性别一列只能在'男'或者'女'这两个字符串之间选择一个，相当于一个单选框～
举例：
创建表如下：
```sql
CREATE TABLE test_enum(
season ENUM('春','夏','秋','冬','unknow')
);
```
添加数据：
```sql
INSERT INTO test_enum
VALUES('春'),('秋');
# 忽略大小写
INSERT INTO test_enum
VALUES('UNKNOW');
# 允许按照角标的方式获取指定索引位置的枚举值
INSERT INTO test_enum
VALUES('1'),(3);
# Data truncated for column 'season' at row 1
INSERT INTO test_enum
VALUES('ab');
# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的
INSERT INTO test_enum
VALUES(NULL);
```
## 9. SET类型
SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。
当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：

| 成员个数范围（L表示实际成员个数） | 占用的存储空间 |
| --- | --- |
| 1 <= L <= 8 | 1个字节 |
| 9 <= L <= 16 | 2个字节 |
| 17 <= L <= 24 | 3个字节 |
| 25 <= L <= 32 | 4个字节 |
| 33 <= L <= 64 | 8个字节 |

SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次 选择多个成员，这一点与ENUM类型不同。
有的时候某一列的值可以在给定的字符串列表中挑选多个，假设学生的基本信息加了一列兴趣属性，这个属性的值可以从给定的兴趣列表中挑选多个，那我们可以使用SET类型，它的格式如下：
```sql
SET('str1', 'str2', 'str3' ⋯)
```
它表示可以在给定的字符串列表里选择多个。我们的兴趣一列就可以定义成SET('打球', '画画', '扯犊子', '玩游戏')类型。这个的意思就是兴趣一列可以在给定的这几个字符串中选择一个或多个，相当于一个多选框～效果就像这样：

| 学号 | 姓名 | ··· | 兴趣 |
| --- | --- | --- | --- |
| 20180101 | 杜子腾 | ··· | '打球', '画画' |
| 20180102 | 杜琦燕 | ··· | '扯犊子' |
| 20180103 | 范统 | ··· | '扯犊子', '玩游戏' |
| 20180104 | 史珍香 | ··· | '画画', '扯犊子', '玩游戏' |

综上所述，ENUM和SET类型都是一种特殊的字符串类型，在从字符串列表中单选或多选元素的时候会用得到它们。
举例：
创建表：
```sql
REATE TABLE test_set(
s SET ('A', 'B', 'C')
);
```
向表中插入数据：
```sql
INSERT INTO test_set (s) VALUES ('A'), ('A,B');
#插入重复的SET类型成员时，MySQL会自动删除重复的成员
INSERT INTO test_set (s) VALUES ('A,B,C,A');
#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。
INSERT INTO test_set (s) VALUES ('A,B,C,D');
SELECT *
FROM test_set;
```
举例：
```sql
CREATE TABLE temp_mul(
gender ENUM('男','女'),
hobby SET('吃饭','睡觉','打豆豆','写代码')
);
```
```sql
INSERT INTO temp_mul VALUES('男','睡觉,打豆豆'); #成功
# Data truncated for column 'gender' at row 1
INSERT INTO temp_mul VALUES('男,女','睡觉,写代码'); #失败
# Data truncated for column 'gender' at row 1
INSERT INTO temp_mul VALUES('妖','睡觉,写代码');#失败
INSERT INTO temp_mul VALUES('男','睡觉,写代码,吃饭'); #成功
```
## 10. 二进制字符串类型
MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。
MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和LONGBLOB类型。
### （1）BINARY与VARBINARY类型
BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。
BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储 1个字节 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充'\0'以补齐指定长度。
VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型 必须指定(M) ，否则报错。

| 二进制字符串类型 | 特点 | 值的长度 | 占用空间 |
| --- | --- | --- | --- |
| BINARY(M)  | 固定长度 | M （0 <= M <= 255） | M个字节 |
| VARBINARY(M)  | 可变长度 | M（0 <= M <= 65535） | M+1个字节 |

### （2）BLOB类型
BLOB是一个 二进制大对象 ，可以容纳可变数量的数据。
MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如 图片 、 音频 和 视频 等。
需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到MySQL中。

| 二进制字符串类型 | 值的长度 | 长度范围 | 占用空间 |
| --- | --- | --- | --- |
| TINYBLOB  | L | 0 <= L <= 255  | L + 1 个字节 |
| BLOB  | L | 0 <= L <= 65535（相当于64KB） | L + 2个字节 |
| MEDIUMBLOB  | L | 0 <= L <= 16777215 （相当于16MB） | L + 3 个字节 |
| LONGBLOB | L | 0 <= L <= 4294967295（相当于4GB）  | L + 4 个字节 |

**TEXT和BLOB的使用注意事项：**
在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。
① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的" 空洞 "，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理 。
② 如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。
③ 把BLOB或TEXT列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。
## 11.JSON类型
JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。**JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。**
在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。 创建数据表，表中包含一个JSON类型的字段 js 
## 12.空间类型
MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用 Geometry（几何） 来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。
MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 。

- Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的子类。
   - Point，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)，坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。
   - LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的（simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,4040)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。
   - Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。

下面展示几种常见的几何图形元素：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718799974355-7a61f420-c28b-47c7-99a1-14c29cb4ec81.png#averageHue=%23eeeeee&clientId=u3e5a2ee4-0606-4&from=paste&height=330&id=u6c59cfee&originHeight=513&originWidth=914&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=113391&status=done&style=none&taskId=u5a86779b-ad7a-417d-aa17-4872e1050d6&title=&width=588.2000122070312)

- MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这4种类型都是集合类，是多个Point、LineString或Polygon组合而成。

下面展示的是多个同类或异类几何图形元素的组合：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718800047172-fa26b822-e18b-4559-9c39-06cc0376d841.png#averageHue=%23eeeeee&clientId=u3e5a2ee4-0606-4&from=paste&height=454&id=u42b5ea3e&originHeight=641&originWidth=887&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=243727&status=done&style=none&taskId=u87905920-82c2-404b-9c84-2a74401e573&title=&width=627.6000366210938)
## 13. 小结及选择建议
在定义数据类型时，如果确定是 整数 ，就用 INT ； 如果是 小数 ，一定用定点数类型 DECIMAL(M,D) ； 如果是日期与时间，就用 DATETIME 。 这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性 好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。
关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：
**阿里巴巴《Java开发手册》之MySQL数据库：**

-  任何字段如果为非负数，必须是 UNSIGNED 
-  【 强制 】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。
说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。 
-  【 强制 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。 
-  【 强制 】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 

# 第十一章 约束
## 1. 约束(constraint)概述
### （1）为什么需要约束
数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。
为了保证数据的完整性，SQL规范以约束的方式对**表数据进行额外的条件限制**。从以下四个方面考虑：

- 实体完整性（Entity Integrity） ：例如，同一个表中，不能存在两条完全相同无法区分的记录
- 域完整性（Domain Integrity） ：例如：年龄范围0-120，性别范围“男/女”
- 引用完整性（Referential Integrity） ：例如：员工所在部门，在部门表中要能找到这个部门
- 用户自定义完整性（User-defined Integrity） ：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。
### （2）什么是约束
约束是表级的强制规定。
可以在**创建表时规定约束（通过 CREATE TABLE 语句），**或者在**表创建之后通过 ALTER TABLE 语句规定约束**。
### （3）约束的分类

- **根据约束数据列的限制**，约束可分为： 
   - **单列约束**：每个约束只约束一列
   - **多列约束**：每个约束可约束多列数据
- **根据约束的作用范围**，约束可分为： 
   - **列级约束**：只能作用在一个列上，跟在列的定义后面
   - **表级约束**：可以作用在多个列上，不与列一起，而是单独定义
|  | 位置 | 支持的约束类型 | 是否可以起约束名 |
| --- | --- | --- | --- |
| 列级约束 | 列的后面 | 语法都支持，但外键没有效果 | 不可以 |
| 表级约束 | 所有列的下面 | 默认和非空不支持，其他支持 | 可以（主键没有效果） |

- **根据约束起的作用**，约束可分为： 
   - **NOT NULL 非空约束，规定某个字段不能为空**
   - **UNIQUE 唯一约束，规定某个字段在整个表中是唯一的**
   - **PRIMARY KEY 主键(非空且唯一)约束**
   - **FOREIGN KEY 外键约束**
   - **CHECK 检查约束**
   - **DEFAULT 默认值约束**
> 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果

- 如何添加/ 删除约束？

CREATE TABLE时添加约束
ALTER TABLE时增加约束、删除约束

- 查看某个表已有的约束
```sql
#information_schema数据库名（系统库）
#table_constraints表名称（专门存储各个表的约束）
SELECT * FROM information_schema.table_constraints
WHERE table_name = '表名称';
```
## 2. 非空约束
### （1) 作用
限定某个字段/ 某列的值不允许为空值(NULL)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718852225348-5dfe9904-e409-4dcd-92a5-ce91a2e0d2a4.png#averageHue=%23eeeeed&clientId=uea4d10d2-c37a-4&from=paste&height=261&id=u6558e30f&originHeight=326&originWidth=915&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=112645&status=done&style=none&taskId=u15175280-c851-4b29-b5cd-5283fd062b6&title=&width=732)
### （2) 关键字
NOT NULL
### （3) 特点

- 如果一个列没有明确指定是否允许空值，那么默认情况下，该列是允许包含空值的。这意味着任何数据类型，包括整数（INT）、浮点数（FLOAT）等，都可以存储空值。
- 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空
- 一个表可以有很多列都分别限定了非空
- 空字符串''不等于NULL，0也不等于NULL
### （4) 添加非空约束
**1. 建表时**
```sql
CREATE TABLE 表名称(
  字段名 数据类型,
  字段名 数据类型 NOT NULL,
  字段名 数据类型 NOT NULL
);
```
举例：
```sql
CREATE TABLE emp(
id INT(10) NOT NULL,
NAME VARCHAR(20) NOT NULL,
sex CHAR NULL
);
```
```sql
CREATE TABLE student(
sid int,
 sname varchar(20) not null,
 tel char(11) ,
 cardid char(18) not null
);
```
```sql
insert into student values(1,'张三','13710011002','110222198912032545'); #成功
insert into student values(2,'李四','13710011002',null);#身份证号为空
ERROR 1048 (23000): Column 'cardid' cannot be null
insert into student values(2,'李四',null,'110222198912032546');#成功，tel允许为空
insert into student values(3,null,null,'110222198912032547');#失败
ERROR 1048 (23000): Column 'sname' cannot be null
```
**2. 建表后**
```sql
alter table 表名称 modify 字段名 数据类型 not null;
```
这条SQL语句是用来修改已存在的数据库表中的列属性的。具体来说，它将一个列的数据类型更改为指定的数据类型，并且添加了非空约束。下面是对这条语句的详细分析：
**语法解释**

- ALTER TABLE 表名称: 指定要修改的表。
- MODIFY 字段名: 指定要修改的列名。
- 数据类型: 指定新的数据类型，这可以是任何有效的SQL数据类型，比如INT, VARCHAR, DATE等。
- NOT NULL: 添加非空约束，确保在该列中插入或更新数据时，必须提供非空的值。

举例：
```sql
ALTER TABLE emp
MODIFY sex VARCHAR(30) NOT NULL;
```
```sql
alter table student modify sname varchar(20) not null;
```
### （5) 删除非空约束
```sql
alter table 表名称 modify 字段名 数据类型 NULL;
#去掉not null，相当于修改某个非注解字段，该字段允许为空
或
alter table 表名称 modify 字段名 数据类型;
#去掉not null，相当于修改某个非注解字段，该字段允许为空
```
举例：
```sql
ALTER TABLE emp
MODIFY sex VARCHAR(30) NULL;
```
```sql
ALTER TABLE emp
MODIFY NAME VARCHAR(15) DEFAULT 'abc' NULL;
```
## 3. 唯一性约束
### （1) 作用
用来限制某个字段/某列的值不能重复。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718865800548-dfdc2c6d-a806-48a4-b94e-4aaeccf4b8d2.png#averageHue=%23f8f7f6&clientId=uea4d10d2-c37a-4&from=paste&height=406&id=u79671474&originHeight=507&originWidth=916&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=76318&status=done&style=none&taskId=ufe7a6296-2731-467e-8ac2-84ee0550ac5&title=&width=732.8)
### （2) 关键字
UNIQUE
### （3) 特点

- 同一个表可以有多个唯一约束。
- 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。
- 唯一性约束允许列值为空。
- 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。
- **MySQL会给唯一约束的列上默认创建一个唯一索引。**
### （4) 添加唯一约束
**1. 建表时**
```sql
create table 表名称(
字段名 数据类型,
字段名 数据类型 unique,
字段名 数据类型 unique key,
字段名 数据类型
);
```

1. **UNIQUE**：
   - 字段名 数据类型 UNIQUE 表示该字段的值必顗唯一，不允许重复。
   - 例如，如果在 字段名 列上定义了 UNIQUE 约束，那么每个值都必须是唯一的。
2. **UNIQUE KEY**：
   - 字段名 数据类型 UNIQUE KEY 也表示该字段的值必顗唯一，并且创建一个唯一索引来加速查询。
   - 唯一索引的作用是确保索引列中的值不重复，并在检索数据时提供快速访问。
```sql
create table 表名称(
字段名 数据类型,
字段名 数据类型,
字段名 数据类型,
[constraint 约束名] unique key(字段名)
);
```

1. **[CONSTRAINT 约束名] UNIQUE KEY (字段名)**：
   - 这部分定义了一个唯一键约束（Unique Key Constraint）。
   - [CONSTRAINT 约束名] 是可选的，用于指定约束的名称。
   - UNIQUE KEY (字段名) 指定了哪个字段（或字段组合）需要唯一性约束，并且会创建一个唯一索引来实现这个约束。
   - 唯一索引确保被索引的列或列组合中的每个值都是唯一的，这样就不允许在表中插入重复的值。

举例：
```sql
CREATE TABLE USER(
  id INT NOT NULL,
  NAME VARCHAR(25),
  PASSWORD VARCHAR(16),
  -- 使用表级约束语法
  CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)
);
```
分析：
**CONSTRAINT uk_name_pwd UNIQUE(NAME, PASSWORD)**：

   - 这是一个表级别的唯一性约束的定义。
   - CONSTRAINT uk_name_pwd 是给这个约束起的名称，uk_name_pwd 可以是任意合法的标识符，用于在未来引用这个约束。
   - UNIQUE(NAME, PASSWORD) 定义了这个唯一性约束，表示组合 (NAME, PASSWORD) 的值必须是唯一的。
   - 这个约束将确保表中的每行数据在 (NAME, PASSWORD) 这个组合上都是唯一的。

由于这个表级别的唯一性约束，对于 USER 表中的每一行，组合 (NAME, PASSWORD) 的值都必顗是唯一的。这意味着在插入新数据或更新现有数据时，系统会检查 (NAME, PASSWORD) 组合是否已经存在，如果已经存在则会拒绝插入或更新操作。
```sql
insert into student values(1,'张三','13710011002','101223199012015623');
insert into student values(2,'李四','13710011003','101223199012015624');
```
```sql
insert into student values(3,'王五','13710011004','101223199012015624'); #身份证号重复
ERROR 1062 (23000): Duplicate entry '101223199012015624' for key 'cardid'
insert into student values(3,'王五','13710011003','101223199012015625');
ERROR 1062 (23000): Duplicate entry '13710011003' for key 'tel'
```
> 表示用户名和密码组合不能重复


**2. 建表后指定唯一键约束**
```sql
#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯
一的
#方式1：
alter table 表名称 add unique key(字段列表);
# key可省略
```

- **ALTER TABLE 表名称**：这部分表示对一个已经存在的表进行修改。**表名称**需要替换为你想要修改的表的实际名称。
- **ADD UNIQUE KEY(字段列表)**：这部分表示在表中添加一个唯一键约束。**字段列表**表示要添加唯一键约束的列或列的组合。这些列的组合必须是唯一的
- **KEY：**在这个语法中，**KEY** 关键字是唯一键约束的一个组成部分。虽然在某些SQL数据库（如MySQL）中，**KEY** 关键字是可选的，但它被用来明确指示这是一个键约束。常见的SQL标准中，唯一键约束通常使用 **UNIQUE** 关键字，而 **KEY** 可以帮助明确这个唯一键是索引的一部分。
```sql
#方式2：
alter table 表名称 modify 字段名 字段类型 unique;
```

- **ALTER TABLE 表名称**：这部分表示对一个已经存在的表进行修改。**表名称**需要替换为你想要修改的表的实际名称。
- **MODIFY 字段名 字段类型 UNIQUE**：这部分表示修改指定字段的类型，并为该字段添加唯一键约束。

举例：
```sql
ALTER TABLE USER
ADD UNIQUE(NAME,PASSWORD);
```
在名为 **USER** 的表中添加一个组合唯一键约束，确保 **NAME** 和 **PASSWORD** 两列的组合在表中是唯一的
```sql
ALTER TABLE USER
ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);
```

- **ALTER TABLE USER**：表示要修改名为 **USER** 的表。
- **ADD CONSTRAINT uk_name_pwd**：表示要添加一个名为 **uk_name_pwd** 的约束。
- **UNIQUE(NAME, PASSWORD)**：指定约束类型为唯一键，并应用于 **NAME** 和 **PASSWORD** 列的组合。
```sql
ALTER TABLE USER
MODIFY NAME VARCHAR(20) UNIQUE;
```
修改 **USER** 表中的 **NAME** 列，将其数据类型更改为 **VARCHAR(20)**，并添加一个唯一键约束，确保 **NAME** 列的值在表中是唯一的。
```sql
create table student(
sid int primary key,
 sname varchar(20),
 tel char(11) ,
 cardid char(18)
);
alter table student add unique key(tel);
alter table student add unique key(cardid);
```
### 5) 关于复合唯一约束
```sql
create table 表名称(
  字段名 数据类型,
  字段名 数据类型,
  字段名 数据类型,
  unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多
  个字段的组合是唯一的
);
```
“多个字段的组合是唯一的”这句话的意思是，在数据库表中，指定的多个字段的值的组合必须是唯一的。换句话说，在同一个表中，任何两行数据在这些字段上的值组合都不能完全相同。这种唯一性约束称为复合唯一键约束。比如约束三个字段，两行数据可以其中两个字段完全相同，但不能三个都完全相同
### 示例和详细解释
假设我们有一个表 **users**，其中包含三个字段：**first_name**（名字），**last_name**（姓氏），**email**（电子邮件）。我们希望确保在表中不存在两行数据具有相同的名字、姓氏和电子邮件组合。我们可以使用复合唯一键约束来实现这一点。
### 创建表并添加复合唯一键约束
```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  email VARCHAR(100),
  UNIQUE KEY (first_name, last_name, email)
);
```
在这个例子中：

- **UNIQUE KEY (first_name, last_name, email)**：这行代码定义了一个复合唯一键约束，确保 **first_name**、**last_name** 和 **email** 的组合在表中是唯一的。
### 意义

- **唯一组合**：表中的每一行必须有唯一的 **first_name**、**last_name** 和 **email** 组合。这意味着不允许有两行数据的 **first_name**、**last_name** 和 **email** 值完全相同。
- **数据完整性**：这种约束有助于维护数据的完整性和一致性，防止重复数据的插入。
### 示例数据
#### 允许的插入
```sql
INSERT INTO users (id, first_name, last_name, email) VALUES (1, 'John', 'Doe', 'john.doe@example.com');
INSERT INTO users (id, first_name, last_name, email) VALUES (2, 'Jane', 'Doe', 'jane.doe@example.com');
INSERT INTO users (id, first_name, last_name, email) VALUES (3, 'John', 'Doe', 'john.different@example.com');
```
在这三个插入语句中，**first_name**、**last_name** 和 **email** 的组合是唯一的，因此插入操作将成功。
#### 不允许的插入
```sql
INSERT INTO users (id, first_name, last_name, email) VALUES (4, 'John', 'Doe', 'john.doe@example.com');
```
这个插入语句将失败，因为已经存在一行数据具有相同的 **first_name**、**last_name** 和 **email** 值（即 'John', 'Doe', '[john.doe@example.com](mailto:john.doe@example.com)'）。复合唯一键约束不允许这种重复。
### （6) 删除唯一约束

- 添加唯一性约束的列上也会自动创建唯一索引。
- 删除唯一约束只能通过删除唯一索引的方式删除。
- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。
- 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；
- 如果是组合列，那么默认和() 中排在第一个的列名相同。也可以自定义唯一性约束名。
```sql
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; #查看都有哪些约束
```
这段代码是一条SQL查询语句，用于从数据库的information_schema中的table_constraints视图检索信息。下面是对这段代码的分析：

- SELECT *: 这表示选择所有列的数据。
- FROM information_schema.table_constraints: 这指定了查询的来源是information_schema数据库中的table_constraints表。information_schema是MySQL数据库的一个特殊模式，它包含了关于所有其他数据库的元数据。table_constraints表存储了关于数据库中所有表的约束信息，比如主键、外键、唯一约束等。
- WHERE table_name = '表名': 这是一个条件语句，用于筛选出表名为指定值（即 '表名' 所代表的实际表名）的记录。这里的 '表名' 应该被替换成你想要查询的具体表名。

总的来说，这条SQL语句的目的是检索出特定表名的所有约束信息。执行这条语句后，你将得到关于那张表的所有约束的详细信息，包括约束类型（比如PRIMARY KEY、FOREIGN KEY等）、约束名称等。
```sql
ALTER TABLE USER
DROP INDEX uk_name_pwd;
```

- DROP INDEX: 这个命令用于删除表的一个索引。索引是用来优化查询性能的数据库对象，它可以加快数据检索速度，但会占用额外的存储空间，并且在插入、删除或更新数据时可能会降低性能。
- uk_name_pwd: 这是要删除的索引的名称。索引名通常是由创建索引时指定的名称，或者是由数据库系统自动生成的名称。

将这条语句放在一起，ALTER TABLE USER DROP INDEX uk_name_pwd; 的意思是：修改USER表，删除名为uk_name_pwd的索引。
> 注意：可以通过 show index from 表名称;        #查看表的索引

## 4. PRIMARY KEY 约束（主键约束）
### （1) 作用
用来唯一标识表中的一行记录。
### （2) 关键字
primary key（主键）
### （3) 特点（用蓝色标识出）
①主键约束相当于**唯一约束+非空约束的组合**，主键约束列不允许重复，也不允许出现空值。
这句话的意思是：在数据库表中，主键约束（Primary Key Constraint）实际上是两种约束的结合：

1. **唯一约束（UNIQUE Constraint）**：保证列中的所有值都是唯一的，即不能有重复的值。
2. **非空约束（NOT NULL Constraint）**：保证列中的所有值都不是空值，即每个记录在该列中必须有一个有效的值。

具体来说，主键约束在数据库表中具有以下特点：

- **不允许重复值**：表中的每一行记录在主键列中的值必须是唯一的。例如，如果你有一个学生表，以学生ID作为主键，那么每个学生的ID必须是不同的，不能有两个学生的ID相同。
- **不允许空值**：主键列中的值不能为NULL，这意味着每条记录都必须有一个有效的主键值。例如，如果学生ID是主键，那么每个学生记录必须有一个ID，不能留空。

**什么是主键？**
Primary Key（主键）是数据库表中一列或多列的组合，其主要作用是唯一标识表中的每一行记录。主键具有以下特征：

1. **唯一性**：主键列中的值必须是唯一的，即在同一张表中，不能有两行记录具有相同的主键值。
2. **非空性**：主键列中的值不能为NULL。这意味着每一行记录都必须有一个有效的主键值。
3. **自动索引**：数据库管理系统通常会自动为主键列创建索引，以提高查询和数据操作的性能。

![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718958016108-b48432aa-3e54-405a-a852-8928e81cdd1a.png#averageHue=%23f8f7f7&clientId=udc1aaf68-73d9-4&from=paste&height=564&id=uefaa135d&originHeight=705&originWidth=1082&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=103016&status=done&style=none&taskId=u36fcf571-40b0-4072-a23e-d90c7094e4d&title=&width=865.6)
②一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。
这句话的分析如下：
**一个表最多只能有一个主键约束**

1. **唯一性**：在一个数据库表中，只能定义一个主键约束。主键的目的是唯一标识表中的每一行记录，因此一个表中不允许存在多个主键约束。
2. **组合主键**：虽然一个表只能有一个主键约束，但这个主键可以由多个列组合而成，这被称为复合主键。例如，一个订单表可以使用**order_id**和**product_id**的组合作为主键。

**在列级别创建主键约束**
列级别的主键约束是在创建或修改表的定义时直接在列定义中指定的。这种方式适用于主键由单一列构成的情况。
**示例：列级别主键约束**
```sql
CREATE TABLE students (
  student_id INT PRIMARY KEY,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  date_of_birth DATE
);
```
在这个例子中，**student_id**列被定义为主键列，主键约束直接在列定义中指定。
**在表级别创建主键约束**
表级别的主键约束是在创建或修改表的定义时在所有列定义之后统一指定的。这种方式适用于主键由单一列或多列组合而成的情况。
**示例：表级别主键约束（单列主键）**
```sql
CREATE TABLE students (
  student_id INT,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  date_of_birth DATE,
  PRIMARY KEY (student_id)
);
```
在这个例子中，主键约束在所有列定义之后指定，表明**student_id**列是主键。
**示例：表级别主键约束（复合主键）**
```sql
CREATE TABLE enrollments (
  student_id INT,
  course_id INT,
  enrollment_date DATE,
  PRIMARY KEY (student_id, course_id)
);
```
在这个例子中，主键约束在所有列定义之后指定，表明**student_id**和**course_id**列的组合是主键。
③主键约束对应着表中的一列或者多列（复合主键）
④如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。
⑤**MySQL的主键名总是PRIMARY**，就算自己命名了主键约束名也没用。
这句话的意思是，在MySQL中，虽然可以给主键约束指定一个名称，但实际上MySQL内部始终将主键约束的名称设为"PRIMARY"。无论用户在创建主键约束时指定了什么名称，MySQL都不会使用用户提供的名称，而是统一使用"PRIMARY"来标识主键约束。
**具体分析**

1. **主键约束名称**：在某些数据库系统（如Oracle或SQL Server）中，可以为主键约束指定一个自定义名称。例如：
```sql
CREATE TABLE students (
  student_id INT,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  PRIMARY KEY CONSTRAINT pk_student_id (student_id)
);
```
在上述示例中，主键约束被命名为**pk_student_id**。

2. **MySQL中的主键约束名称**：在MySQL中，即使你尝试为主键约束指定一个自定义名称，MySQL也会忽略这个名称，而是始终使用"PRIMARY"作为主键约束的名称。例如：
```sql
CREATE TABLE students (
  student_id INT,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  CONSTRAINT pk_student_id PRIMARY KEY (student_id)
);
```
尽管在上面的语句中试图将主键约束命名为**pk_student_id**，MySQL实际上会将主键约束的名称设置为"PRIMARY"。
⑥当创建主键约束时，系统默认会在所在的列或列组合上建立对应的**主键索引**（能够根据主键查询的，就根据主键查询，效率更高。如果删除主键约束了，主键约束对应的索引就自动删除了。
⑦需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。
1）主键字段的值是什么？
主键字段的值是数据库表中用于唯一标识每一行记录的值。具体来说，主键值的特征和作用如下：
**作用**

1. **唯一标识记录**：通过主键值，可以唯一标识表中的每一行记录。例如，在一个学生表中，**student_id**可以作为主键，每个学生都有一个独特的**student_id**。
2. **建立关系**：主键值可以在其他表中作为外键被引用，从而建立表之间的关系。例如，在一个成绩表中，可以使用学生表中的**student_id**作为外键，表示成绩记录属于哪个学生。
3. **提高查询效率**：数据库通常会为主键创建索引，从而提高数据查询的效率。

**示例**
假设有一个学生表（students），其主键是**student_id**：
```sql
CREATE TABLE students (
  student_id INT PRIMARY KEY,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  date_of_birth DATE
);
```
在这个表中，每一行记录的**student_id**值就是该行记录的主键值。例如：
```sql
INSERT INTO students (student_id, first_name, last_name, date_of_birth) VALUES
(1, 'John', 'Doe', '2000-01-01'),
(2, 'Jane', 'Smith', '1999-05-15');

```
在这个例子中，**student_id**的值分别是1和2，它们唯一标识了表中的每一行记录。
2）分析这句话
这句话强调了在数据库操作中，不要轻易修改主键字段的值，原因如下：
数据完整性

1. **唯一标识**：主键是每条记录在表中的唯一标识符。如果修改了主键值，可能会导致唯一标识失效。例如，假设有一个学生表，学生ID是主键。如果修改了某个学生的ID，可能会导致在该表中无法唯一标识该学生的记录。
2. **引用完整性**：在关系数据库中，主键通常会在其他表中作为外键被引用。如果修改了主键值，可能会破坏这些引用关系，导致数据不一致。例如，假设有一个成绩表，学生ID作为外键引用学生表的主键。如果修改了学生表中的学生ID，成绩表中的外键引用将变得无效，导致数据的参照完整性被破坏。
### （4) 添加主键约束
**1. 建表时指定主键约束**
```sql
create table 表名称(
  字段名 数据类型 primary key, #列级模式
  字段名 数据类型,
  字段名 数据类型
);

create table 表名称(
  字段名 数据类型,
  字段名 数据类型,
  字段名 数据类型,
  [constraint 约束名] primary key(字段名) #表级模式
);
```
**2. 建表后增加主键约束**
```sql
ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); 
#字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键
```
### （5) 关于复合主键
```sql
create table 表名称(
  字段名 数据类型,
  字段名 数据类型,
  字段名 数据类型,
  primary key(字段名1,字段名2) 
  #表示字段1和字段2的组合是唯一的，也可以有更多个字段
);
```
### 6) 删除主键约束
```sql
alter table 表名称 drop primary key
```
> 说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。
> 分析：当提到“删除主键约束后，非空还存在”时，这句话的意思是，在数据库中删除一列的主键约束，并不会自动删除该列上的非空（NOT NULL）约束。这两个约束是独立的，即使一个列不再作为主键，非空约束仍然可以独立存在并生效

## 5. 自增列：AUTO_INCREMENT
### （1) 作用
某个字段的值自增
### （2) 关键字
auto_increment
### （3) 特点
（1）一个表最多只能有一个自增长列
（2）当需要产生唯一标识符或顺序值时，可设置自增长
（3）自增长列约束的列必须是键列（主键列，唯一键列）
（4）自增约束的列的数据类型必须是整数类型
（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。
（5）的分析：这句话描述了在数据库管理系统（如MySQL）中，对于自增列（Auto Increment Column）的行为：

1. **如果自增列指定了 0 和 null**：当插入一行数据时，如果为自增列（通常是主键）指定了值 0 或 NULL，数据库会忽略这个值，并自动根据当前表中自增列的最大值，生成一个新的自增值并插入。
   - 例如，如果当前表的自增列最大值是 5，插入一行数据并为自增列指定 0 或 NULL，那么自增列会自动生成 6 作为新行的值。
2. **如果自增列手动指定了具体值**：当插入一行数据时，如果为自增列明确指定了一个具体值（不是 0 或 NULL），数据库会直接使用这个指定的值，不会自动生成新值。
   - 例如，如果当前表的自增列最大值是 5，插入一行数据并明确指定自增列的值为 10，那么数据库会将 10 作为新行的自增列的值。

这个机制的主要目的是为了灵活管理自增列的值，既能自动递增以保证唯一性，又能在特定情况下手动设置具体值。
错误演示：
（1）
```sql
create table employee(
eid int auto_increment,
 ename varchar(20)
);
# ERROR 1075 (42000): Incorrect table definition; there can be only one auto column
and it must be defined as a key 
```
你的代码创建一个名为 **employee** 的表，其中包含一个自增列 **eid** 和一个名为 **ename** 的列。语法上有一个小问题，**eid** 列应该被定义为主键，以确保自增列的唯一性和完整性。
正确的代码应如下：
```sql
CREATE TABLE employee (
  eid INT AUTO_INCREMENT PRIMARY KEY,
  ename VARCHAR(20)
);
```
（2）
```sql
create table employee(
eid int primary key,
 ename varchar(20) unique key auto_increment
);
# ERROR 1063 (42000): Incorrect column specifier for column 'ename' 因为ename不是整数类
型
```
这段代码中有几处问题需要修正：

1. **ename** 列的定义中使用了 **auto_increment** 关键字。**AUTO_INCREMENT** 只能应用于整数类型的列，因此在 **VARCHAR** 列上使用 **AUTO_INCREMENT** 是不合法的。
2. 关键字 **unique key** 应该是 **UNIQUE**。

以下是修正后的代码：
```sql
CREATE TABLE employee (
  eid INT PRIMARY KEY AUTO_INCREMENT,
  ename VARCHAR(20) UNIQUE
);
```
### （4) 如何指定自增约束
**1. 建表时**
```sql
create table 表名称(
  字段名 数据类型 primary key auto_increment,
  ……
);
create table 表名称(
  字段名 数据类型 unique key auto_increment,
  ……
);
```
**2. 建表后**
```sql
alter table 表名称 modify 字段名 数据类型 auto_increment;
```
### （5) 删除自增约束
```sql
#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束
alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除
```
### （6) MySQL 8.0新特性—自增变量的持久化
在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL 5.7版本中，测试步骤如 下： 创建的数据表中包含自增主键的id字段，语句如下：
```sql
CREATE TABLE test1(
  id INT PRIMARY KEY AUTO_INCREMENT
);
```
在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典 内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。
在MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志 中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。
## 6. FOREIGN KEY 约束（外键约束）
### （1）作用
限定某个表的某个字段的引用完整性。
比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/33643071/1718963980148-93c865d8-3324-48a3-9a70-dfb060c78dac.png#averageHue=%23f5f5f5&clientId=udc1aaf68-73d9-4&from=paste&height=467&id=u045b308b&originHeight=584&originWidth=1134&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101596&status=done&style=none&taskId=u0531e8f5-0989-421c-9ca9-f864b5967f5&title=&width=907.2)
### （2）关键字
FOREIGN KEY
### （3) 主表和从表/父表和子表
主表（父表）：被引用的表，被参考的表
从表（子表）：引用别人的表，参考别人的表
例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。
例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。
### （4) 特点(蓝色)
（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列
为什么？因为被依赖/被参考的值必须是唯一的
分析：①**外键（Foreign Key）**：外键是一个表中的一个或多个列，其值引用另一个表（主表或父表）中的列的值。外键用于确保两个表之间的数据一致性和完整性。
②为什么被依赖/被参考的值必须是唯一的
被依赖/被参考的值必须是唯一的原因主要涉及数据库的完整性、数据一致性和有效的数据引用。以下是详细分析：
1. 确保数据的一致性

- **唯一标识**：外键列用于在从表（子表）中引用主表（父表）的特定行。如果主表中被引用的列（即外键引用的目标列）不是唯一的，从表中的某个外键值可能对应主表中的多行。这会导致无法唯一确定引用的对象，从而引起数据的不一致性。
- **数据完整性**：确保被引用的值在主表中是唯一的，可以防止出现多对多或一对多的模糊关系，保持数据的完整性和准确性。

2. 防止数据重复和冗余

- **避免重复值**：主键或唯一约束确保每个值在主表中是独一无二的，防止重复值的出现。如果允许被引用的值有重复，从表中的某个外键值无法明确指向主表中的唯一一行，这会引起数据重复和冗余。
- **参照完整性**：外键关系依赖于被引用的唯一值，以确保从表中的外键值能够明确映射到主表中的一行。没有唯一性约束可能导致无法有效地进行数据引用和管理。

3. 数据库操作的可靠性

- **更新和删除操作**：在主表中进行更新或删除操作时，如果被引用的列不唯一，将会对这些操作的执行造成混淆。例如，如果删除一个主表行，所有引用该行的从表行也应删除（或更新为其他值），这需要引用的列是唯一的以确保操作的确定性。
- **优化查询性能**：唯一性约束有助于数据库优化器更高效地执行查询操作，因为唯一性约束提供了明确的索引路径，从而加快数据访问速度。

（2）在创建外键约束时，如果不给外键约束命名，**默认名不是列名，而是自动产生一个外键名**（例如 student_ibfk_1;），也可以指定外键约束名。
**分析**

1. **自动产生的外键名**：
   - 如果在创建外键约束时没有显式地给出一个约束名称，数据库管理系统（DBMS）会自动生成一个名称。
   - 这个自动生成的名称通常是系统生成的一个唯一标识符，格式可能因具体的 DBMS 而异。例如，在 MySQL 中，自动生成的外键约束名可能类似于 **student_ibfk_1**。
2. **默认名不是列名**：
   - 自动生成的外键约束名并不会使用外键列的名称。相反，DBMS 会使用一种标准的命名模式来生成唯一的约束名称。这是为了确保约束名在数据库中是唯一的，避免命名冲突。
3. **可以指定外键约束名**：
   - 在创建外键约束时，用户可以显式地指定一个名称。这有助于在以后对约束进行管理时更方便地引用。例如，修改或删除外键约束时，指定名称会使操作更加直观和明确。

（3）创建(CREATE)表时就指定外键约束的话，**先创建主表**，再创建从表
（4）删表时，**先删从表**（或先删除外键约束），再删除主表
（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据
（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束
（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can't create table'database.tablename'(errno: 150)”。 
例如：都是表示部门编号，都是int类型。
（8）当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。（根据外键查询效率很高）
（9）删除外键约束后，必须**手动**删除对应的索引
### （5）添加外键约束
**1. 建表时**
```sql
create table 主表名称(
  字段1 数据类型 primary key,
  字段2 数据类型
);

create table 从表名称(
  字段1 数据类型 primary key,
  字段2 数据类型,
  [CONSTRAINT <外键约束名称>] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)
);
#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样
#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样
-- FOREIGN KEY: 在表级指定子表中的列
-- REFERENCES: 标示在父表中的列
```
从表的代码分析：

1. **字段1 数据类型 PRIMARY KEY**：
   - **字段1** 是列名，需要用实际的列名替换。
   - **数据类型** 是该列的数据类型，例如 **INT**、**VARCHAR(50)** 等。
   - **PRIMARY KEY** 指定该列为主键，主键是唯一的且不能为空。
2. **[CONSTRAINT <外键约束名称>]**（可选）：
   - **CONSTRAINT** 关键字用于定义一个约束，并可以指定一个名称。
   - **<外键约束名称>** 是外键约束的名称，用户可以为约束指定一个有意义的名称来方便管理。方括号表示这是一个可选部分。
3. **FOREIGN KEY (从表的某个字段)**：
   - **FOREIGN KEY** 关键字用于定义外键。
   - **从表的某个字段** 是外键列名，需要用实际的列名替换。这个列将引用另一个表的某列。
4. **REFERENCES 主表名(被参考字段)**：
   - **REFERENCES** 关键字用于指定外键引用的目标表和列。
   - **主表名** 是被引用的表名，需要用实际的表名替换。
   - **被参考字段** 是被引用的列名，需要用实际的列名替换。这个列通常是主键或具有唯一约束的列。
```sql
create table dept( #主表
  did int primary key, #部门编号
  dname varchar(50) #部门名称
);
create table emp(#从表
  eid int primary key, #员工编号
  ename varchar(5), #员工姓名
  deptid int, #员工所在的部门
  foreign key (deptid) references dept(did) #在从表中指定外键约束
  #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号
);
说明：
（1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。
（2）删除表时，先删除从表emp，再删除主表dept
```
**2. 建表后**
一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不 过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那 么，就要用修改表的方式来补充定义。
格式：
```sql
ALTER TABLE 从表名 
ADD [CONSTRAINT 约束名] 
FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];
```
这段代码用于在现有的表中添加一个外键约束。

1. **ADD [CONSTRAINT 约束名]**（可选）：
   - **ADD** 用于添加新的列或约束。
   - **CONSTRAINT** 关键字用于定义一个约束，并可以指定一个名称。
   - **约束名** 是外键约束的名称，用户可以为约束指定一个有意义的名称来方便管理。方括号表示这是一个可选部分。
2. **FOREIGN KEY (从表的字段)**：
   - **FOREIGN KEY** 关键字用于定义外键。
   - **从表的字段** 是外键列名，需要用实际的列名替换。这个列将引用另一个表的某列。
3. **REFERENCES 主表名(被引用字段)**：
   - **REFERENCES** 关键字用于指定外键引用的目标表和列。
   - **主表名** 是被引用的表名，需要用实际的表名替换。
   - **被引用字段** 是被引用的列名，需要用实际的列名替换。这个列通常是主键或具有唯一约束的列。
4. **[ON UPDATE xx] 和 [ON DELETE xx]**（可选）：
   - **ON UPDATE** 子句定义了当引用的主表记录被更新时，从表中的外键记录应该执行的动作。**xx** 是动作，可以是 **CASCADE**、**SET NULL**、**SET DEFAULT** 或 **RESTRICT** 等。
   - **ON DELETE** 子句定义了当引用的主表记录被删除时，从表中的外键记录应该执行的动作。**xx** 是动作，可以是 **CASCADE**、**SET NULL**、**SET DEFAULT** 或 **RESTRICT** 等。

举例：
```sql
ALTER TABLE emp1
ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);
```
这段代码通过 **ALTER TABLE** 语句在现有的 **emp1** 表中添加一个外键约束。这个外键约束确保 **emp1** 表中的 **dept_id** 列的值必须存在于 **dept** 表的 **dept_id** 列中，从而维护了数据的一致性和完整性。通过命名外键约束（**emp_dept_id_fk**），可以更方便地管理约束，例如修改或删除。
```sql
create table dept(
did int primary key, #部门编号
 dname varchar(50) #部门名称
);
create table emp(
eid int primary key,  #员工编号
 ename varchar(5),   #员工姓名
 deptid int #员工所在的部门
);
#这两个表创建时，没有指定外键的话，那么创建顺序是随意
```
```sql
alter table emp add foreign key (deptid) references dept(did);
```
### （6）演示问题
（1）失败：不是键列
```sql
create table dept(
did int , #部门编号
 dname varchar(50) #部门名称
);
create table emp(
eid int primary key,  #员工编号
 ename varchar(5),   #员工姓名
 deptid int, #员工所在的部门
  foreign key (deptid) references dept(did)
);
#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是dept的did不是键列
```
这段代码的问题在于 **dept** 表中的 **did** 列不是键列，也就是说它没有被定义为主键或唯一键。为了让 **emp** 表中的 **deptid** 列作为外键引用 **dept** 表中的 **did** 列，**did** 列必须是主键或者具有唯一约束。
**键列定义**
在关系数据库中，键列（Key Column）是用于唯一标识每一行记录的列。常见的键列包括：

- **主键（Primary Key）**：唯一标识表中每一行记录的列，不能包含空值。
- **唯一键（Unique Key）**：确保列中的所有值是唯一的，可以包含空值（但一个列中只能有一个空值）。

（2）失败：数据类型不一致
```sql
create table dept(
did int primary key, #部门编号
 dname varchar(50) #部门名称
);
create table emp(
eid int primary key,  #员工编号
 ename varchar(5),   #员工姓名
 deptid char, #员工所在的部门
  foreign key (deptid) references dept(did)
);
#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是从表的deptid字段和主表的did字
段的数据类型不一致，并且要它俩的逻辑意义一致
```
（3）成功，两个表字段名一样
```sql
create table dept(
  did int primary key, #部门编号
  dname varchar(50) #部门名称
);
create table emp(
  eid int primary key,  #员工编号
  ename varchar(5),   #员工姓名
  did int, #员工所在的部门
  foreign key (did) references dept(did) 
  #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号
  #是否重名没问题，因为两个did在不同的表中
);
```
（4）添加、删除、修改问题
```sql
create table dept(
did int primary key, #部门编号
 dname varchar(50) #部门名称
);
create table emp(
eid int primary key,  #员工编号
 ename varchar(5),   #员工姓名
 deptid int, #员工所在的部门
  foreign key (deptid) references dept(did) 
  #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号
);
```
```sql
insert into dept values(1001,'教学部');
insert into dept values(1003, '财务部');
insert into emp values(1,'张三',1001); #添加从表记录成功，在添加这条记录时，要求部门表有1001部门
insert into emp values(2,'李四',1005);#添加从表记录失败
ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row: a foreign key
constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`)
REFERENCES `dept` (`did`)) 从表emp添加记录失败，因为主表dept没有1005部门
```
```sql
update emp set deptid = 1002 where eid = 1;#修改从表失败
ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row（子表的记录）: a
foreign key constraint fails（外键约束失败） (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1`
FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #部门表did字段现在没有1002的值，所以员工
表中不能修改员工所在部门deptid为1002
update dept set did = 1002 where did = 1001;#修改主表失败
ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表的记录）: a
foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY
(`deptid`) REFERENCES `dept` (`did`)) #部门表did的1001字段已经被emp引用了，所以部门表的1001字
段就不能修改了。
update dept set did = 1002 where did = 1003;#修改主表成功 因为部门表的1003部门没有被emp表引
用，所以可以修改
```
```sql
delete from dept where did=1001; #删除主表失败
ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表记录）: a
foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY
(`deptid`) REFERENCES `dept` (`did`))  #因为部门表did的1001字段已经被emp引用了，所以部门表的
1001字段对应的记录就不能被删除
```
总结：约束关系是针对双方的

- 添加了外键约束后，主表的修改和删除数据受约束
- 添加了外键约束后，从表的添加和修改数据受约束
- 在从表上建立外键，要求主表必须存在
- 删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除
### （7）约束等级

- `Cascade方式`：在父表上update/delete记录时，同步update/delete掉子表的匹配记录
- `Set null方式` ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子 表的外键列不能为not null
- `No action方式` ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作
- `Restrict方式` ：同no action， 都是立即检查外键约束
- `Set default方式` （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别x

如果没有指定等级，就相当于Restrict方式。 
对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式。
分析：在 SQL 中，**ON UPDATE CASCADE** 和 **ON DELETE RESTRICT** 是外键约束的动作选项，用于定义当主表中的记录被更新或删除时，子表中的相关记录应该执行的操作。这些选项有助于维护数据的一致性和完整性。
①ON UPDATE CASCADE
**ON UPDATE CASCADE** 指定当主表中的被引用列的值更新时，子表中的相应外键列值也会自动更新为新的值。这确保了子表中的引用保持一致。
②ON DELETE RESTRICT
**ON DELETE RESTRICT** 指定当试图删除主表中的一条记录，而该记录被子表中的外键引用时，拒绝删除操作。这避免了删除主表记录导致子表中出现孤立的引用。
（1）演示1：on update cascade on delete set null
```sql
create table dept(
did int primary key, #部门编号
 dname varchar(50) #部门名称
);
create table emp(
eid int primary key,  #员工编号
 ename varchar(5),   #员工姓名
 deptid int, #员工所在的部门
  foreign key (deptid) references dept(did)  on update cascade on delete set null
  #把修改操作设置为级联修改等级，把删除操作设置为set null等级
);
```
举例：
```sql
insert into dept values(1001,'教学部');
insert into dept values(1002, '财务部');
insert into dept values(1003, '咨询部');
insert into emp values(1,'张三',1001); #在添加这条记录时，要求部门表有1001部门
insert into emp values(2,'李四',1001);
insert into emp values(3,'王五',1002);
```
```sql
#修改主表成功，从表也跟着修改，修改了主表被引用的字段1002为1004，从表的引用字段就跟着修改为1004了
mysql> update dept set did = 1004 where did = 1002;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql> select * from dept;
+------+--------+
| did | dname |
+------+--------+
| 1001 | 教学部 |
| 1003 | 咨询部 |
| 1004 | 财务部 | #原来是1002，修改为1004
+------+--------+
3 rows in set (0.00 sec)
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|  1 | 张三 |  1001 |
|  2 | 李四 |  1001 |
|  3 | 王五 |  1004 | #原来是1002，跟着修改为1004
+-----+-------+--------+
3 rows in set (0.00 sec)
```
```sql
#删除主表的记录成功，从表对应的字段的值被修改为null
mysql> delete from dept where did = 1001;
Query OK, 1 row affected (0.01 sec)
mysql> select * from dept;
+------+--------+
| did | dname | #记录1001部门被删除了
+------+--------+
| 1003 | 咨询部 |
| 1004 | 财务部 |
+------+--------+
2 rows in set (0.00 sec)
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|  1 | 张三 |  NULL | #原来引用1001部门的员工，deptid字段变为null
|  2 | 李四 |  NULL |
|  3 | 王五 |  1004 |
+-----+-------+--------+
3 rows in set (0.00 sec
```
（2）演示2：on update set null on delete cascade
```sql
create table dept(
did int primary key, #部门编号
 dname varchar(50) #部门名称
);
create table emp(
eid int primary key,  #员工编号
 ename varchar(5),   #员工姓名
 deptid int, #员工所在的部门
  foreign key (deptid) references dept(did)  on update set null on delete cascade
  #把修改操作设置为set null等级，把删除操作设置为级联删除等级
);
```
```sql
insert into dept values(1001,'教学部');
insert into dept values(1002, '财务部');
insert into dept values(1003, '咨询部');
insert into emp values(1,'张三',1001); #在添加这条记录时，要求部门表有1001部门
insert into emp values(2,'李四',1001);
insert into emp values(3,'王五',1002);
```
```sql
mysql> select * from dept;
+------+--------+
| did | dname |
+------+--------+
| 1001 | 教学部 |
| 1002 | 财务部 |
| 1003 | 咨询部 |
+------+--------+
3 rows in set (0.00 sec)
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|  1 | 张三 |  1001 |
|  2 | 李四 |  1001 |
|  3 | 王五 |  1002 |
+-----+-------+--------+
3 rows in set (0.00 sec)
```
```sql
#修改主表，从表对应的字段设置为null
mysql> update dept set did = 1004 where did = 1002;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql> select * from dept;
+------+--------+
| did | dname |
+------+--------+
| 1001 | 教学部 |
| 1003 | 咨询部 |
| 1004 | 财务部 | #原来did是1002
+------+--------+
3 rows in set (0.00 sec)
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|  1 | 张三 |  1001 |
|  2 | 李四 |  1001 |
|  3 | 王五 |  NULL | #原来deptid是1002，因为部门表1002被修改了，1002没有对应的了，就设置为
null
+-----+-------+--------+
3 rows in set (0.00 sec)
```
```sql
#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了
mysql> delete from dept where did=1001;
Query OK, 1 row affected (0.00 sec)
mysql> select * from dept;
+------+--------+
| did | dname | #部门表中1001部门被删除
+------+--------+
| 1003 | 咨询部 |
| 1004 | 财务部 |
+------+--------+
2 rows in set (0.00 sec)
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |#原来1001部门的员工也被删除了
+-----+-------+--------+
|  3 | 王五 |  NULL |
+-----+-------+--------+
1 row in set (0.00 sec)
```
### （8）删除外键约束
流程如下：
```sql
(1)第一步先查看约束名和删除外键约束
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';  #查看某个表的约束名
ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;

（2）第二步查看索引名和删除索引。（注意，只能手动删除）
SHOW INDEX FROM 表名称; #查看某个表的索引名
ALTER TABLE 从表名 DROP INDEX 索引名;
```
举例：
```sql
mysql> SELECT * FROM information_schema.table_constraints WHERE table_name = 'emp';
mysql> alter table emp drop foreign key emp_ibfk_1;
Query OK, 0 rows affected (0.02 sec)
Records: 0 Duplicates: 0  Warnings: 0
```
```sql
mysql> show index from emp;
mysql> alter table emp drop index deptid;
Query OK, 0 rows affected (0.01 sec)
Records: 0 Duplicates: 0  Warnings: 0
mysql>  show index from emp;
```
### （9）开发场景
**问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否 一定要建外键约束？**
答：不是的
**问题2：建和不建外键约束有什么区别？**
答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限 制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。
不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的 引用完整 性 ，只能依靠程序员的自觉 ，或者是 在Java程序中进行限定 。例如：在员工表中，可以添加一个员工的 信息，它的部门指定为一个完全不存在的部门。
**问题3：那么建和不建外键约束和查询有没有关系？**
答：没有
> 在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许你不使用系统自带的外键约束，在 应用层面 完成检查数据一致性的逻辑。也就是说，即使你不 用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。

### （10）阿里开发规范
【 强制 】不得使用外键与级联，一切外键概念必须在应用层解决。
说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单 机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响 数据库的 插入速度 。
## 7. CHECK 约束
### （1）作用
检查某个字段的值是否符号xx要求，一般指的是值的范围
### （2) 关键字
CHECK
### （3) 说明
MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告
但是**MySQL 8.0中可以使用check约束了**。
```sql
create table employee(
  eid int primary key,
  ename varchar(5),
  gender char check ('男' or '女')
);
```
```sql
insert into employee values(1,'张三','妖'); #插入失败
```
## 8. DEFAULT约束
### （1）作用
给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。
### （2）关键字
DEFAULT
### （3）添加默认值
**1. 建表时**
```sql
create table 表名称(
  字段名 数据类型 primary key,
  字段名 数据类型 unique key not null,
  字段名 数据类型 unique key,
  字段名 数据类型 not null default 默认值,
);
```
```sql
说明：默认值约束一般不在唯一键和主键列上加
```
**2. 建表后**
```sql
alter table 表名称 modify 字段名 数据类型 default 默认值;
#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了
#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了
alter table 表名称 modify 字段名 数据类型 default 默认值 not null;
```
（1）#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了
分析：这句话的意思是在对已有字段添加默认值约束时，如果该字段已经有非空（NOT NULL）约束，那么必须明确保留非空约束，否则在添加默认值的过程中，非空约束可能会被移除
**背景**
在某些数据库系统中，当修改表结构来添加默认值约束时，如果没有明确保留现有的非空约束，可能会导致非空约束被移除。这取决于具体的数据库系统和版本。
**示例和解释**
假设我们有一个 `employee` 表，其中 `gender` 列有非空约束：
```sql
CREATE TABLE employee (
    eid INT PRIMARY KEY,
    ename VARCHAR(5),
    gender CHAR NOT NULL
);
```
现在，我们想要为 `gender` 列添加默认值 `'男'`，同时保留非空约束。
**正确的方法**
在 MySQL 中，我们可以通过以下方式添加默认值并保留非空约束：
```sql
ALTER TABLE employee MODIFY gender CHAR NOT NULL DEFAULT '男';
```

- `**ALTER TABLE employee MODIFY gender CHAR NOT NULL DEFAULT '男'**`: 
   - `MODIFY` 子句用于更改列的定义。
   - 明确指定 `NOT NULL` 约束，以确保在添加默认值时，非空约束不会被移除。
   - 添加 `DEFAULT '男'`，为 `gender` 列设置默认值。

**错误的方法**
如果只添加默认值而没有明确保留非空约束，可能会导致非空约束被移除：
```sql
ALTER TABLE employee MODIFY gender CHAR DEFAULT '男';
```

- `**ALTER TABLE employee MODIFY gender CHAR DEFAULT '男'**`: 
   - 这条语句只添加了默认值约束，但没有重新声明非空约束。
   - 结果可能导致 `gender` 列的非空约束被移除。

（2）#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了
这句话解释了在给某个字段添加非空约束时，如果该字段已经有默认值约束，那么必须在 `MODIFY` 语句中明确保留默认值约束，否则默认值约束会被删除。这同样适用于在修改字段时保留现有的约束，确保数据的一致性和完整性。
**示例和解释**
假设我们有一个 `employee` 表，其中 `gender` 列有默认值约束：
```sql
CREATE TABLE employee (
    eid INT PRIMARY KEY,
    ename VARCHAR(5),
    gender CHAR DEFAULT '男'
);
```
现在，我们想要为 `gender` 列添加非空约束，同时保留默认值 `'男'`。
**正确的方法**
在 MySQL 中，我们可以通过以下方式添加非空约束并保留默认值约束：
```sql
ALTER TABLE employee MODIFY gender CHAR NOT NULL DEFAULT '男';
```
**错误的方法**
如果只添加非空约束而没有明确保留默认值约束，可能会导致默认值约束被移除：
```sql
ALTER TABLE employee MODIFY gender CHAR NOT NULL;
```

- `**ALTER TABLE employee MODIFY gender CHAR NOT NULL**`: 
   - 这条语句只添加了非空约束，但没有重新声明默认值约束。
   - 结果可能导致 `gender` 列的默认值约束被移除。

**3.删除默认值**
```sql
alter table 表名称 modify 字段名 数据类型; #删除默认值约束，也不保留非空约束
alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束
```
## 9. 面试
**面试1、为什么建表时，加 not null default '' 或 default 0**
答：不想让表中出现null值。
**面试2、为什么不想要 null 的值**
答:
（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通 常返回null。
（2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default '' 或 default 0
**面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？**
在MySQL中，默认AUTO_INCREMENT的初始 值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第 一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一 条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要 设置字段自动增加属性。
**面试4、并不是每个表都可以任意选择存储引擎？**
外键约束（FOREIGN KEY）不能跨引擎使用。
MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来 保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不 能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。
# 


